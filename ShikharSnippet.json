{
	//use snippet-generator.app.com
	//, after a snippet
	"rolling hash for k length subarray": {
		"prefix": "rolling",
		"body": [
		  "const long long mod = 1e9 + 7;",
		  "    string ans = \"\";",
		  "    bool f(string &s, int k){",
		  "        int n = s.size();",
		  "        long long p = 0;",
		  "        for(int i = 0; i < k; i++){",
		  "            p = ((p * 26) % mod + (s[i] - 'a')) % mod;",
		  "        }",
		  "        long long h = 1;",
		  "        for(int i = 0; i < k - 1; i++){",
		  "            h = (h * 26) % mod;",
		  "        }",
		  "        unordered_map<long int,vector<int>> mm;",
		  "        mm[p].push_back(0);",
		  "        for(int i = k; i < n; i++){",
		  "            p = (((p - (s[i - k] - 'a') * h) + (mod * 100)) * 26 + (s[i] - 'a')) % mod;",
		  "            if(mm[p].size()){",
		  "                string kk = s.substr(i-k+1, k);",
		  "                for(auto pp: mm[p]){",
		  "                    string lmn = s.substr(pp, k);",
		  "                    if(lmn == kk) {",
		  "                        ans = lmn;",
		  "                        return true;",
		  "                    }",
		  "                }",
		  "            }",
		  "            ",
		  "            mm[p].push_back(i - k + 1);",
		  "        }",
		  "        return false;",
		  "    }"
		],
		"description": "rolling hash for k length subarray"
	  },
	"UF = UnionFind(MaxN)": {
		"prefix": "UF",
		"body": [
		  "struct UnionFind {",
		  "",
		  "    vector<int> par;",
		  "    vector<int> sizes;",
		  "",
		  "    UnionFind(int n)",
		  "            : par(n), sizes(n, 1) {",
		  "        for (int i = 0; i < n; i++) {",
		  "            par[i] = i;",
		  "        }",
		  "    }",
		  "",
		  "    int find(int x) {",
		  "        return x == par[x] ? x : par[x] = find(par[x]);",
		  "    }",
		  "",
		  "    bool unite(int x, int y) {",
		  "        x = find(x);",
		  "        y = find(y);",
		  "        if (x == y) return false;",
		  "        if (sizes[x] < sizes[y]) swap(x, y);",
		  "        par[y] = x;",
		  "        sizes[x] += sizes[y];",
		  "        return true;",
		  "    }",
		  "",
		  "    bool same(int x, int y) {",
		  "        return find(x) == find(y);",
		  "    }",
		  "",
		  "    int get_size(int x) {",
		  "        return sizes[find(x)];",
		  "    }",
		  "",
		  "    bool all_same() {",
		  "        bool good = true;",
		  "        for (int i = 0, n = par.size(); i < n; i++) if (find(0) != find(i)) good = false;",
		  "        return good;",
		  "    }",
		  "",
		  "    int get_connectivity() {",
		  "        set<int> s;",
		  "        for (int i = 0, n = par.size(); i < n; i++) s.insert(find(i));",
		  "        return s.size();",
		  "    }",
		  "",
		  "};"
		],
		"description": "UF = UnionFind(MaxN)"
	  },
	"centroid of a tree, at most 2 centroids and min 1 centroid": {
		"prefix": "centroid",
		"body": [
		  "vector<int> Centroid(const vector<vector<int>> &g) {",
		  "        int n = g.size();",
		  "        vector<int> centroid;",
		  "        vector<int> sz(n);",
		  "        function<void (int, int)> dfs = [&](int u, int prev) {",
		  "                sz[u] = 1;",
		  "                bool is_centroid = true;",
		  "                for (auto v : g[u]) if (v != prev) {",
		  "                        dfs(v, u);",
		  "                        sz[u] += sz[v];",
		  "                        if (sz[v] > n / 2) is_centroid = false;",
		  "                }",
		  "                if (n - sz[u] > n / 2) is_centroid = false;",
		  "                if (is_centroid) centroid.push_back(u);",
		  "        };",
		  "        dfs(0, -1);",
		  "        return centroid;",
		  "}"
		],
		"description": "centroid of a tree, at most 2 centroids and min 1 centroid"
	  },
	"cp template": {
		"prefix": "cp",
		"body": [
		  "#include<bits/stdc++.h>",
		  "using namespace std;",
		  "",
		  "#define int long long",
		  "#define f(i,b) for(int (i)=0;(i)<(b);(i)++)",
		  "#define fx(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)",
		  "#define fr(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)",
		  "#define ft(i,s) for(auto i = s.begin(); i != s.end(); i++)",
		  "#define IOS ios::sync_with_stdio(0); cin.tie(0);",
		  "#define ff first",
		  "#define ss second",
		  "#define inp(a) f(i,a.size()){cin >> a[i];}",
		  "#define pb push_back",
		  "#define mp make_pair",
		  "#define MAX 1e9",
		  "#define endl '\\n'",
		  "#define setb(x) __builtin_popcountll(x)",
		  "#define msb(x) (64 - __builtin_clzll(x))",
		  "#define rb(n) (n&(-n))",
		  "#define rbm(n) (n&(n-1))",
		  "#define vi vector<int>",
		  "#define all(x) x.begin(),x.end()",
		  "#define sortd(x) sort(all(x),greater<int>());",
		  "#define sorta(x) sort(all(x));",
		  "#define mid (l+(r-l)/2)",
		  "",
		  "void yn(bool truth){",
		  "    if(truth) cout << \"YES\" << endl;",
		  "    else cout << \"NO\" << endl;",
		  "}",
		  "int cl(int x, int y){",
		  "    if(x%y == 0) return x/y;",
		  "    else return x/y+1;",
		  "}",
		  "void pri(vi& x){",
		  "    f(i,x.size()){",
		  "        cout << x[i] << \" \";",
		  "    }",
		  "    cout << endl;",
		  "}",
		  "//cout << setprecision(15) << f << endl;",
		  "",
		  "void solve(){",
		  "    //write code here",
		  "    int n;",
		  "    cin >> n;",
		  "    $1",
		  "}",
		  "",
		  "signed main() {",
		  "    IOS",
		  "    int t;",
		  "    cin >> t;",
		  "    //spff();",
		  "    //sieve();",
		  "    //cntprimN();",
		  "    while(t--)",
		  "        solve();",
		  "}",
		  ""
		],
		"description": "cp template"
	  },
	"input for tree": {
		"prefix": "treeinp",
		"body": [
		  "vector<vector<int>> g(n+1);",
		  "int l, r;",
		  "f(i,n-1){",
		  "    cin >> l >> r;",
		  "    g[l].pb(r);",
		  "    g[r].pb(l);",
		  "}"
		],
		"description": "input for tree"
	  },
	"dfs for tree": {
		"prefix": "dfstree",
		"body": [
		  "void dfs(vector<vi>& g, int s, int p = -1){",
		  "    for(auto x: g[s]){",
		  "        if(x == p)",
		  "            continue;",
		  "        $1",
		  "        dfs(g, x, s);",
		  "    }",
		  "}"
		],
		"description": "dfs for tree"
	  },
	"finds inverisons in an array in nlog(n)": {
		"prefix": "inversionmerge",
		"body": [
		  "int join(vi &a, int l, int r){",
		  "    int i = l, j = mid+1;",
		  "    int ans = 0;",
		  "    vi newar;",
		  "    while(i <= mid && j <= r){",
		  "        if(a[i] <= a[j]){",
		  "            newar.pb(a[i]);",
		  "            ++i;",
		  "            ans += j - mid - 1;",
		  "        }",
		  "        else{",
		  "            newar.pb(a[j]);",
		  "            ++j;",
		  "        }",
		  "    }",
		  "    if(i <= mid){",
		  "        while(i <= mid){",
		  "            ans += r-mid;",
		  "            newar.pb(a[i]);",
		  "            ++i;",
		  "        }",
		  "    }",
		  "    if(j <= r){",
		  "        while(j <= r){",
		  "            newar.pb(a[j]);",
		  "            ++j;",
		  "        }",
		  "    }",
		  "    int cnt = 0;",
		  "    fx(i,l,r) a[i] = newar[cnt++];",
		  "    return ans;",
		  "}",
		  "",
		  "int merge(vi &a, int l, int r){",
		  "    if(l == r) return 0;",
		  "    return merge(a, l, mid) + merge(a, mid+1, r) + join(a, l, r);",
		  "}",
		  "",
		  "int inversion(vi a){",
		  "    return merge(a, 0, a.size()-1);",
		  "}"
		],
		"description": "finds inverisons in an array in nlog(n)"
	  },
	"log_power": {
		"prefix": "pow",
		"body": [
		  "int pow(int x, int n){",
		  "  int ans=1;",
		  "  while(n){",
		  "    if(n&1){",
		  "      ans=ans*x;",
		  "    }",
		  "    x=x*x;",
		  "    n=n>>1;",
		  "  }",
		  "  return ans;",
		  "}"
		],
		"description": "log_power"
	  },
	"log_power_with_mod": {
		"prefix": "mpow",
		"body": [
		  "const int mod = 1e9+7$1;",
		  "int mpow(int x, int n){",
		  "  int ans = 1;",
		  "  while(n){",
		  "    if(n&1){",
		  "      ans=(ans*x)%mod;",
		  "    }",
		  "    x=(x*x)%mod;",
		  "    n=n>>1;",
		  "  }",
		  "  return ans;",
		  "}"
		],
		"description": "log_power_with_mod"
	  },
	"primes till an N <= 1e6": {
		"prefix": "cntprime",
		"body": [
		  "vector<int> count_pr(1000001,0);",
		  "void cntprimN(){",
		  "  //use with sieve",
		  "  count_pr[2] = 1;",
		  "  fx(i,3,1000000){",
		  "    count_pr[i]=(prim[i])?1+count_pr[i-1]:count_pr[i-1];",
		  "  }",
		  "}"
		],
		"description": "primes till an N <= 1e6"
	  },
	"gcd": {
		"prefix": "gcd",
		"body": [
		  "int gcd(int a ,int b){",
		  "   if(b==0) return a;",
		  "   a%=b;",
		  "   return gcd(b,a);",
		  "}"
		],
		"description": "gcd"
	  },
	"fast prime factor": {
		"prefix": "spf",
		"body": [
		  "vector<int> spf(10000001);",
		  "void spff(){",
		  "  fx(i,1,10000000){",
		  "  spf[i] = i;",
		  "  }",
		  "  fx(i,2,10000000){",
		  "    if(spf[i] == i){",
		  "      int x=i*i;",
		  "      while(x<=10000000){",
		  "        if(spf[x] == x){",
		  "          spf[x] = i;",
		  "        }",
		  "        x+=i;",
		  "      }",
		  "    }",
		  "  }",
		  "}",
		  "void fact(int n){",
		  "  while(n > 1){",
		  "    //spf[n] is the factor here",
		  "    $1",
		  "    n = n/spf[n];",
		  "  }",
		  "}"
		],
		"description": "fast prime factor"
	  },
	"prime_sieve": {
		"prefix": "sieve",
		"body": [
		  "vector<bool> prim(1000001,true);",
		  "void sieve(){",
		  "  fx(i,2,1000000){",
		  "    if(prim[i]){",
		  "      int x=2*i;",
		  "      while(x<=1000000){",
		  "      prim[x]=false;",
		  "      x+=i;",
		  "      }",
		  "    }",
		  "  }",
		  "}"
		],
		"description": "prime_sieve"
	  },
	  "kadane's algo": {
		"prefix": "kadane",
		"body": [
		  "int kadane(vi &a){",
		  "  int m=0,ma=0;",
		  "  f(i,a.size()){",
		  "    ma+=a[i];",
		  "    ma=(ma<0)?0:ma;",
		  "    if(m<ma)m=ma;",
		  "  }",
		  "  return m;",
		  "}"
		],
		"description": "kadane's algo"
	  }
}
