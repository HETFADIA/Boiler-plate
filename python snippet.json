{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"boilerplate": {
		"prefix": "boilerplate",
		"body": [
			"from itertools import combinations, permutations, combinations_with_replacement, product",
			"",
			"import itertools",
			"from timeit import timeit",
			"import timeit",
			"import time",
			"from time import time",
			"import collections",
			"import bisect",
			"import os",
			"import math",
			"from collections import defaultdict, OrderedDict, Counter",
			"from sys import stdin, stdout",
			"from bisect import bisect_left, bisect_right",
			"# import numpy as np",
			"from queue import Queue, PriorityQueue",
			"from heapq import *",
			"from statistics import *",
			"from math import sqrt, log10, log2, log, gcd, ceil, floor",
			"import fractions",
			"import copy",
			"from copy import deepcopy",
			"import sys",
			"import io",
			"import string",
			"from string import ascii_lowercase, ascii_uppercase, ascii_letters, digits",
			"sys.setrecursionlimit(10000)",
			"",
			"mod = int(pow(10, 9)) + 7",
			"",
			"",
			"def ncr(n, r, p=mod):",
			"    num = den = 1",
			"    for i in range(r):",
			"        num = (num * (n - i)) % p",
			"        den = (den * (i + 1)) % p",
			"    return (num * pow(den,",
			"                      p - 2, p)) % p",
			"",
			"",
			"def normalncr(n, r):",
			"    r = min(r, n - r)",
			"    count = 1",
			"    for i in range(n - r, n + 1):",
			"        count *= i",
			"",
			"    for i in range(1, r + 1):",
			"        count //= i",
			"    return count",
			"",
			"",
			"inf = float(\"inf\")",
			"adj = defaultdict(set)",
			"visited = defaultdict(int)",
			"",
			"",
			"def addedge(a, b):",
			"    adj[a].add(b)",
			"    adj[b].add(a)",
			"",
			"",
			"def bfs(v):",
			"    q = Queue()",
			"    q.put(v)",
			"    visited[v] = 1",
			"    while q.qsize() > 0:",
			"        s = q.get_nowait()",
			"        print(s)",
			"        for i in adj[s]:",
			"            if visited[i] == 0:",
			"                q.put(i)",
			"                visited[i] = 1",
			"",
			"",
			"def dfs(v, visited):",
			"    if visited[v] == 1:",
			"        return",
			"    visited[v] = 1",
			"",
			"    print(v)",
			"    for i in adj[v]:",
			"        dfs(i, visited)",
			"",
			"",
			"# a9=pow(10,5)+100",
			"# prime = [True for i in range(a9 + 1)]",
			"# def SieveOfEratosthenes(n):",
			"#     p = 2",
			"#     while (p * p <= n):",
			"#         if (prime[p] == True):",
			"#             for i in range(p * p, n + 1, p):",
			"#                 prime[i] = False",
			"#         p += 1",
			"# SieveOfEratosthenes(a9)",
			"# prime_number=[]",
			"# for i in range(2,a9):",
			"#     if prime[i]:",
			"#         prime_number.append(i)",
			"",
			"",
			"def reverse_bisect_right(a, x, lo=0, hi=None):",
			"    if lo < 0:",
			"        raise ValueError('lo must be non-negative')",
			"    if hi is None:",
			"        hi = len(a)",
			"    while lo < hi:",
			"        mid = (lo + hi) // 2",
			"        if x > a[mid]:",
			"            hi = mid",
			"        else:",
			"            lo = mid + 1",
			"    return lo",
			"",
			"",
			"def reverse_bisect_left(a, x, lo=0, hi=None):",
			"    if lo < 0:",
			"        raise ValueError('lo must be non-negative')",
			"    if hi is None:",
			"        hi = len(a)",
			"    while lo < hi:",
			"        mid = (lo + hi) // 2",
			"        if x >= a[mid]:",
			"            hi = mid",
			"        else:",
			"            lo = mid + 1",
			"    return lo",
			"",
			"",
			"def get_list():",
			"    return list(map(int, input().split()))",
			"",
			"",
			"def make_list(m):",
			"    m += list(map(int, input().split()))",
			"",
			"",
			"def get_str_list_in_int():",
			"    return [int(i) for i in list(input())]",
			"",
			"",
			"def get_str_list():",
			"    return list(input())",
			"",
			"",
			"def get_map():",
			"    return map(int, input().split())",
			"",
			"",
			"def input_int():",
			"    return int(input())",
			"",
			"",
			"def matrix(a, b):",
			"    return [[0 for i in range(b)] for j in range(a)]",
			"",
			"",
			"def swap(a, b):",
			"    return b, a",
			"",
			"",
			"def find_gcd(l):",
			"    a = l[0]",
			"    for i in range(len(l)):",
			"        a = gcd(a, l[i])",
			"    return a",
			"",
			"",
			"def is_prime(n):",
			"    sqrta = int(sqrt(n))",
			"    for i in range(2, sqrta + 1):",
			"        if n % i == 0:",
			"            return 0",
			"    return 1",
			"",
			"",
			"def prime_factors(n):",
			"    l = []",
			"    while n % 2 == 0:",
			"        l.append(2)",
			"        n //= 2",
			"    sqrta = int(sqrt(n))",
			"",
			"    for i in range(3, sqrta + 1, 2):",
			"        while n % i == 0:",
			"            n //= i",
			"            l.append(i)",
			"    if n > 2:",
			"        l.append(n)",
			"    return l",
			"",
			"",
			"def p(a):",
			"    if type(a) == str:",
			"        print(a + \"\\n\")",
			"    else:",
			"        print(str(a) + \"\\n\")",
			"",
			"",
			"def ps(a):",
			"    if type(a) == str:",
			"        print(a)",
			"    else:",
			"        print(str(a))",
			"",
			"",
			"def kth_no_not_div_by_n(n, k):",
			"    return k + (k - 1) // (n - 1)",
			"",
			"",
			"def forward_array(l):",
			"    \"\"\"",
			"    returns the forward index where the elemetn is just greater than that element",
			"    [100,200] gives [1,2]",
			"    because element at index 1 is greater than 100 and nearest",
			"    similarly if it is largest then it outputs n",
			"    :param l:",
			"    :return:",
			"    \"\"\"",
			"    n = len(l)",
			"    stack = []",
			"    forward = [0] * n",
			"    for i in range(len(l) - 1, -1, -1):",
			"        while len(stack) and l[stack[-1]] < l[i]:",
			"            stack.pop()",
			"        if len(stack) == 0:",
			"            forward[i] = len(l)",
			"        else:",
			"            forward[i] = stack[-1]",
			"        stack.append(i)",
			"    return forward",
			"",
			"",
			"def forward_array_notequal(l):",
			"    n = len(l)",
			"    stack = []",
			"    forward = [n]*n",
			"    for i in range(len(l) - 1, -1, -1):",
			"        while len(stack) and l[stack[-1]] <= l[i]:",
			"            stack.pop()",
			"        if len(stack) == 0:",
			"            forward[i] = len(l)",
			"        else:",
			"            forward[i] = stack[-1]",
			"        stack.append(i)",
			"    return forward",
			"",
			"",
			"def backward_array(l):",
			"    n = len(l)",
			"    stack = []",
			"    backward = [0] * n",
			"    for i in range(len(l)):",
			"        while len(stack) and l[stack[-1]] < l[i]:",
			"            stack.pop()",
			"        if len(stack) == 0:",
			"            backward[i] = -1",
			"        else:",
			"            backward[i] = stack[-1]",
			"        stack.append(i)",
			"    return backward",
			"",
			"",
			"def char(a):",
			"    return chr(a + 97)",
			"",
			"",
			"def get_length(a):",
			"    return 1 + int(log10(a))",
			"",
			"",
			"def issq(n):",
			"    sqrta = int(n ** 0.5)",
			"    return sqrta ** 2 == n",
			"",
			"",
			"def ceil(a, b):",
			"    return int((a+b-1)/b)",
			"",
			"",
			"def equal_sum_partition(arr, n):",
			"    sum = 0",
			"    for i in range(n):",
			"        sum += arr[i]",
			"    if sum % 2 != 0:",
			"        return False",
			"",
			"    part = [[True for i in range(n + 1)]",
			"            for j in range(sum // 2 + 1)]",
			"",
			"    for i in range(0, n + 1):",
			"        part[0][i] = True",
			"",
			"    for i in range(1, sum // 2 + 1):",
			"        part[i][0] = False",
			"",
			"    for i in range(1, sum // 2 + 1):",
			"",
			"        for j in range(1, n + 1):",
			"            part[i][j] = part[i][j - 1]",
			"",
			"            if i >= arr[j - 1]:",
			"                part[i][j] = (part[i][j] or",
			"                              part[i - arr[j - 1]][j - 1])",
			"",
			"    return part[sum // 2][n]",
			"",
			"",
			"def bin_sum_array(arr, n):",
			"    for i in range(n):",
			"        if arr[i] % 2 == 1:",
			"            return i+1",
			"    binarray = [list(reversed(bin(i)[2:])) for i in arr]",
			"    new_array = [0 for i in range(32)]",
			"    for i in binarray:",
			"        for j in range(len(i)):",
			"            if i[j] == '1':",
			"                new_array[j] += 1",
			"    return new_array",
			"",
			"",
			"def ispalindrome(s):",
			"    return s == s[::-1]",
			"",
			"",
			"def get_prefix(l):",
			"    if l == []:",
			"        return []",
			"    prefix = [l[0]]",
			"    for i in range(1, len(l)):",
			"        prefix.append(prefix[-1]+l[i])",
			"    return prefix",
			"",
			"",
			"def get_suffix(l):",
			"    if l == []:",
			"        return []",
			"    suffix = [l[-1]]*len(l)",
			"    for i in range(len(l)-2, -1, -1):",
			"        suffix[i] = suffix[i+1]+l[i]",
			"    return suffix",
			"",
			"",
			"nc = \"NO\"",
			"yc = \"YES\"",
			"ns = \"No\"",
			"ys = \"Yes\"",
			"",
			"",
			"def yesno(a):",
			"    print(yc if a else nc)",
			"",
			"",
			"def reduce(dict, a):",
			"    dict[a] -= 1",
			"    if dict[a] == 0:",
			"        dict.pop(a)",
			"",
			"",
			"# import math as mt",
			"# MAXN=10**7",
			"# spf = [0 for i in range(MAXN)]",
			"# def sieve():",
			"#     spf[1] = 1",
			"#     for i in range(2, MAXN):",
			"#         # marking smallest prime factor",
			"#         # for every number to be itself.",
			"#         spf[i] = i",
			"#",
			"#         # separately marking spf for",
			"#     # every even number as 2",
			"#     for i in range(4, MAXN, 2):",
			"#         spf[i] = 2",
			"#",
			"#     for i in range(3, mt.ceil(mt.sqrt(MAXN))):",
			"#",
			"#         # checking if i is prime",
			"#         if (spf[i] == i):",
			"#",
			"#             # marking SPF for all numbers",
			"#             # divisible by i",
			"#             for j in range(i * i, MAXN, i):",
			"#",
			"#                 # marking spf[j] if it is",
			"#                 # not previously marked",
			"#                 if (spf[j] == j):",
			"#                     spf[j] = i",
			"# def getFactorization(x):",
			"#     ret = list()",
			"#     while (x != 1):",
			"#         ret.append(spf[x])",
			"#         x = x // spf[x]",
			"#",
			"#     return ret",
			"# sieve()",
			"",
			"",
			"# if(os.path.exists('input.txt')):",
			"#     sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\")",
			"# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline",
			"input = sys.stdin.readline",
			"# print=sys.stdout.write",
			"t = 1",
			"",
			"t = int(input())",
			"for i in range(t):",
			"    n, k = get_list()",
			"    l = get_list()",
			""
		],
		"description": "boilerplate"
	},
	"greatest gcd": {
		"prefix": "greatest gcd",
		"body": [
			"def gcd(x, y):",
			"    \"\"\"greatest common divisor of x and y\"\"\"",
			"    while y:",
			"        x, y = y, x % y",
			"    return x"
		],
		"description": "greatest gcd"
	},
	"euclidean division modular": {
		"prefix": "euclidean division modular",
		"body": [
			"def modInverse(b, m):",
			"    g = gcd(b, m)",
			"    if (g != 1):",
			"        return -1",
			"    else:",
			"        return pow(b, m - 2, m)",
			"def modDivide(a, b, m):",
			"    a = a % m",
			"    inv = modInverse(b, m)",
			"    if (inv == -1):",
			"        return inf",
			"    else:",
			"        return (inv*a)%m"
		],
		"description": "euclidean division modular"
	},
	"findiso google": {
		"prefix": "findiso google",
		"body": [
			"def findiso(mat,num=0):",
			"    n=len(mat)",
			"    m=len(mat[0])",
			"    dp=[[0 for j in range(m)] for i in range(n)]",
			"    for i in range(1,n):",
			"        for j in range(1,m-1):",
			"            if mat[i-1][j-1]==mat[i-1][j]==mat[i-1][j+1]==mat[i][j]==num:",
			"                dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])+1",
			"    sum1=sum([sum(i) for i in dp])",
			"    dp = [[0 for j in range(m)] for i in range(n)]",
			"    for i in range(n-2,-1,-1):",
			"        for j in range(m-2,0,-1):",
			"            if mat[i+1][j-1]==mat[i+1][j]==mat[i+1][j+1]==mat[i][j]==num:",
			"                dp[i][j]=min(dp[i+1][j-1],dp[i+1][j],dp[i+1][j+1])+1",
			"    sum2=sum([sum(i) for i in dp])",
			"    return sum1+sum2"
		],
		"description": "findiso google"
	},
	"small boilerplate": {
		"prefix": "small boilerplate",
		"body": [
			"",
			"import sys, io, os",
			"input = sys.stdin.readline",
			"# input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline",
			"# sys.setrecursionlimit(10000)",
			"inf = float('inf')",
			"mod = 10 ** 9 + 7",
			"def yn(a): print(\"YES\" if a else \"NO\")",
			"ceil = lambda a, b: (a + b - 1) // b",
			""
		],
		"description": "small boilerplate"
	},
	"fastio template": {
		"prefix": "fastio template",
		"body": [
			"import os",
			"import sys",
			"from io import BytesIO, IOBase",
			"",
			"BUFSIZE = 8192",
			"",
			"",
			"class FastIO(IOBase):",
			"    newlines = 0",
			"",
			"    def __init__(self, file):",
			"        self._fd = file.fileno()",
			"        self.buffer = BytesIO()",
			"        self.writable = \"x\" in file.mode or \"r\" not in file.mode",
			"        self.write = self.buffer.write if self.writable else None",
			"",
			"    def read(self):",
			"        while True:",
			"            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
			"            if not b:",
			"                break",
			"            ptr = self.buffer.tell()",
			"            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
			"        self.newlines = 0",
			"        return self.buffer.read()",
			"",
			"    def readline(self):",
			"        while self.newlines == 0:",
			"            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
			"            self.newlines = b.count(b\"\\n\") + (not b)",
			"            ptr = self.buffer.tell()",
			"            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
			"        self.newlines -= 1",
			"        return self.buffer.readline()",
			"",
			"    def flush(self):",
			"        if self.writable:",
			"            os.write(self._fd, self.buffer.getvalue())",
			"            self.buffer.truncate(0), self.buffer.seek(0)",
			"",
			"",
			"class IOWrapper(IOBase):",
			"    def __init__(self, file):",
			"        self.buffer = FastIO(file)",
			"        self.flush = self.buffer.flush",
			"        self.writable = self.buffer.writable",
			"        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))",
			"        self.read = lambda: self.buffer.read().decode(\"ascii\")",
			"        self.readline = lambda: self.buffer.readline().decode(\"ascii\")",
			"",
			"",
			"sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)",
			"input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")"
		],
		"description": "fastio template"
	},
	"zfunction": {
		"prefix": "zfunction",
		"body": [
			"def z_function(S):",
			"    \"\"\"",
			"    Z Algorithm in O(n)",
			"    :param S: text string to process",
			"    :return: the Z array, where Z[i] = length of the longest common prefix of S[i:] and S",
			"    \"\"\"",
			"",
			"    n = len(S)",
			"    Z = [0] * n",
			"    l = r = 0",
			"",
			"    for i in range(1, n):",
			"        z = Z[i - l]",
			"        if i + z >= r:",
			"            z = max(r - i, 0)",
			"            while i + z < n and S[z] == S[i + z]:",
			"                z += 1",
			"",
			"            l, r = i, i + z",
			"",
			"        Z[i] = z",
			"",
			"    Z[0] = n",
			"    return Z"
		],
		"description": "zfunction"
	},
	"subset_sum": {
		"prefix": "subset_sum",
		"body": [
			"def subset_sum(l):",
			"    s = {0}",
			"    for i in l:",
			"        temp = []",
			"        for j in s: temp.append(j + i)",
			"        for j in temp: s.add(j)",
			"    return s"
		],
		"description": "subset_sum"
	},
	"subset_sum_count": {
		"prefix": "subset_sum_count",
		"body": [
			"def subset_sum_count(l):",
			"    s = defaultdict(int)",
			"    s[0]=1",
			"    for i in l:",
			"        temp = []",
			"        for j in s: temp.append([j + i,s[j]])",
			"        for j,counter in temp: s[j]+=counter",
			"    return s"
		],
		"description": "subset_sum_count"
	},
	"subset_sum_count_infinite": {
		"prefix": "subset_sum_count_infinite",
		"body": [
			"def subset_sum_count_infinite(l,limit):",
			"    \"\"\"l is a list of positive elements\"\"\"",
			"    dp=[0 for i in range(limit+1)]",
			"    dp[0]=1",
			"    for i in range(1,limit+1):",
			"        for j in l:",
			"            if 0<=i-j<limit+1:",
			"                dp[i]+=dp[i-j]",
			"    return dp"
		],
		"description": "subset_sum_count_infinite"
	},
	"prefixsuffix": {
		"prefix": "prefixsuffix",
		"body": [
			"class Prefix:",
			"    def __init__(self,l=[]):",
			"        self.lista=l[:]",
			"        for i in range(1,len(l)):",
			"            self.lista[i]+=self.lista[i-1]",
			"    def query(self,a,b=-1):",
			"        if b==-1:",
			"            return self.lista[a]",
			"        if a==0:",
			"            return self.lista[b]",
			"        return self.lista[b]-self.lista[a-1]",
			"class Suffix:",
			"    def __init__(self,l=[]):",
			"        self.lista = l[:]",
			"        for i in range(len(l)-2,-1,-1):",
			"            self.lista[i] += self.lista[i + 1]",
			"    def query(self,a,b=inf):",
			"        if b==inf:",
			"            b=len(self.lista)-1",
			"        if b==len(self.lista)-1:",
			"            return self.lista[a]",
			"        return self.lista[a]-self.lista[b+1]"
		],
		"description": "prefixsuffix"
	},
	"maximum_rectange_in_histogram": {
		"prefix": "maximum_rectange_in_histogram",
		"body": [
			"def forward_array_less(l):",
			"    \"\"\"",
			"    returns the forward index where the element is just smaller than that element-1",
			"    [1,2,1,0] gives [3, 2, 3, 4]",
			"    because element at index 1 is greater than 100 and nearest",
			"    similarly if it is largest then it outputs n",
			"    :param l:",
			"    :return:",
			"    \"\"\"",
			"    n = len(l)",
			"    stack = []",
			"    forward = [0] * n",
			"    for i in range(len(l) - 1, -1, -1):",
			"        while len(stack) and l[stack[-1]] >= l[i]:",
			"            stack.pop()",
			"        if len(stack) == 0:",
			"            forward[i] = len(l)",
			"        else:",
			"            forward[i] = stack[-1]",
			"        stack.append(i)",
			"    return forward",
			"def backward_array_less(l):",
			"    n = len(l)",
			"    stack = []",
			"    backward = [0] * n",
			"    for i in range(len(l)):",
			"        while len(stack) and l[stack[-1]] >= l[i]:",
			"            stack.pop()",
			"        if len(stack) == 0:",
			"            backward[i] = -1",
			"        else:",
			"            backward[i] = stack[-1]",
			"        stack.append(i)",
			"    return [i+1 for i in backward]",
			"def maximum_rectange_in_histogram(l):",
			"    stack1=forward_array_less(l)",
			"    stack2=backward_array_less(l)",
			"    maxa=0",
			"    n=len(l)",
			"    for i in range(n):",
			"        maxa=max(maxa,l[i]*(stack1[i]-stack2[i]))"
		],
		"description": "maximum_rectange_in_histogram"
	},
	"maximum_area_in_rectangle": {
		"prefix": "maximum_area_in_rectangle",
		"body": [
			"def forward_array_less(l):",
			"    \"\"\"",
			"    returns the forward index where the element is just smaller than that element-1",
			"    [1,2,1,0] gives [3, 2, 3, 4]",
			"    because element at index 1 is greater than 100 and nearest",
			"    similarly if it is largest then it outputs n",
			"    :param l:",
			"    :return:",
			"    \"\"\"",
			"    n = len(l)",
			"    stack = []",
			"    forward = [0] * n",
			"    for i in range(len(l) - 1, -1, -1):",
			"        while len(stack) and l[stack[-1]] >= l[i]:",
			"            stack.pop()",
			"        if len(stack) == 0:",
			"            forward[i] = len(l)",
			"        else:",
			"            forward[i] = stack[-1]",
			"        stack.append(i)",
			"    return forward",
			"def backward_array_less(l):",
			"    n = len(l)",
			"    stack = []",
			"    backward = [0] * n",
			"    for i in range(len(l)):",
			"        while len(stack) and l[stack[-1]] >= l[i]:",
			"            stack.pop()",
			"        if len(stack) == 0:",
			"            backward[i] = -1",
			"        else:",
			"            backward[i] = stack[-1]",
			"        stack.append(i)",
			"    return [i+1 for i in backward]",
			"def maximum_rectange_in_histogram(l):",
			"    stack1=forward_array_less(l)",
			"    stack2=backward_array_less(l)",
			"    maxa=0",
			"    n=len(l)",
			"    for i in range(n):",
			"        maxa=max(maxa,l[i]*(stack1[i]-stack2[i]))",
			"    return maxa",
			"def maximum_area_in_rectangle(mat,num=1):",
			"    if(len(mat)==0):",
			"        return 0",
			"    n=len(mat)",
			"    m=len(mat[0])",
			"    ans=[]",
			"    for i in range(n):",
			"        for j in range(m):",
			"            if i==0:",
			"                mat[i][j]=(mat[i][j]==num)",
			"            elif mat[i][j]!=num:",
			"                mat[i][j]=0",
			"            else:",
			"                mat[i][j]=mat[i-1][j]+(mat[i][j]==num)",
			"        ans.append(maximum_rectange_in_histogram(mat[i]))",
			"    return max(ans)"
		],
		"description": "maximum_area_in_rectangle"
	},
	"gcd longest segment slow": {
		"prefix": "gcd longest segment slow",
		"body": [
			"def fun(s,diff,k):",
			"    n=len(diff)",
			"    for i in range(n-k+1):",
			"        gcda=s.query(i,i+k)",
			"        if gcda==0:",
			"            return 0",
			"        if gcda>1:",
			"            return 0",
			"    return 1",
			"def discrete_binary_search(func,s,arr, lo, hi):",
			"    \"\"\" Locate the first value x s.t. func(x) = True within [lo, hi] \"\"\"",
			"    while lo < hi:",
			"        mi = lo + (hi - lo) // 2",
			"        # print(mi)",
			"        if func(s,arr,mi):",
			"            hi = mi",
			"        else:",
			"            lo = mi + 1",
			"",
			"    return lo",
			"class RangeQuery:",
			"    def __init__(self, data, func=min):",
			"        self.func = func",
			"        self._data = _data = [list(data)]",
			"        i, n = 1, len(_data[0])",
			"        while 2 * i <= n:",
			"            prev = _data[-1]",
			"            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])",
			"            i <<= 1",
			"        self.bit_len=[0 for i in range(n+1)]",
			"        for i in range(1,n+1):",
			"            self.bit_len[i]=self.bit_len[i//2]+1",
			"",
			"    def query(self, start, stop):",
			"        \"\"\"func of data[start, stop)\"\"\"",
			"        depth = self.bit_len[stop - start] - 1",
			"        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])",
			"",
			"    def __getitem__(self, idx):",
			"        return self._data[0][idx]",
			"",
			"    def gcd_longest_seg(self,arr):",
			"        n=len(arr)",
			"        s=RangeQuery(arr,gcd)",
			"        low=1",
			"        high=n+1",
			"        ans = discrete_binary_search(fun,s,arr, low, high)",
			"        return ans"
		],
		"description": "gcd longest segment slow"
	},
	"getlist": {
		"prefix": "getlist",
		"body": [
			"[int(i) for i in input().split()]"
		],
		"description": "getlist"
	},
	"longestincreasingsubsequence": {
		"prefix": "longest increasing subsequence",
		"body": [
			"def lis(nums, cmp=lambda x, y: x < y):",
			"    P = [0] * len(nums)",
			"    M = [0] * (len(nums) + 1)",
			"    L = 0",
			"",
			"    for i in range(len(nums)):",
			"        lo, hi = 1, L",
			"",
			"        while lo <= hi:",
			"            mid = (lo + hi) // 2",
			"            if cmp(nums[M[mid]], nums[i]):",
			"                lo = mid + 1",
			"            else:",
			"                hi = mid - 1",
			"",
			"        newL = lo",
			"        P[i] = M[newL - 1]",
			"        M[newL] = i",
			"",
			"        L = max(L, newL)",
			"",
			"    S = [0] * L",
			"    k = M[L]",
			"",
			"    for i in range(L - 1, -1, -1):",
			"        S[i], k = nums[k], P[k]",
			"",
			"    return S"
		],
		"description": "longestincreasingsubsequence"
	},
	"stack end and front": {
		"prefix": "stack end and front",
		"body": [
			"def end_array(l,cmp=lambda a,b:a<b):",
			"    \"\"\"",
			"    end[i]-front[i] gives the answer",
			"    a<b lambda for higher index stack",
			"    \"\"\"",
			"    n = len(l)",
			"    stack = []",
			"    forward = [0] * n",
			"    for i in range(len(l) - 1, -1, -1):",
			"        while len(stack) and cmp(l[stack[-1]] , l[i]):",
			"            stack.pop()",
			"        if len(stack) == 0:",
			"            forward[i] = len(l)",
			"        else:",
			"            forward[i] = stack[-1]",
			"        stack.append(i)",
			"    return forward",
			"",
			"def front_array(l,cmp=lambda a,b:a<b):",
			"    n = len(l)",
			"    stack = []",
			"    backward = [0] * n",
			"    for i in range(len(l)):",
			"        while len(stack) and cmp(l[stack[-1]] , l[i]):",
			"            stack.pop()",
			"        if len(stack) == 0:",
			"            backward[i] = 0",
			"        else:",
			"            backward[i] = stack[-1]+1",
			"        stack.append(i)",
			"    return backward"
		],
		"description": "stack end and front"
	},
	"RangeQuery": {
		"prefix": "RangeQuery",
		"body": [
			"class RangeQuery:",
			"    def __init__(self, data, func=min,default=0):",
			"        self.func = func",
			"        self._data = _data = [list(data)]",
			"        self.defualt=default",
			"        i, n = 1, len(_data[0])",
			"        while 2 * i <= n:",
			"            prev = _data[-1]",
			"            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])",
			"            i <<= 1",
			"        self.bit_len=[0 for i in range(n+1)]",
			"        for i in range(1,n+1):",
			"            self.bit_len[i]=self.bit_len[i//2]+1",
			"",
			"    def query_normal(self,start,stop):",
			"        \"\"\"func of data[start, stop) for mutable\"\"\"",
			"        ans=self.defualt",
			"        for j in range(self.bit_len[stop-start]-1,-1,-1):",
			"            if (1<<j)<=stop-start:",
			"                ans=self.func(ans,self._data[j][start])",
			"                start+=(1<<j)",
			"        return ans",
			"",
			"    def query(self, start, stop):",
			"        \"\"\"func of data[start, stop)\"\"\"",
			"        depth = self.bit_len[stop - start] - 1",
			"        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])",
			"",
			"    def __getitem__(self, idx):",
			"        return self._data[0][idx]"
		],
		"description": "RangeQuery"
	},
	"lis_length": {
		"prefix": "lis_length",
		"body": [
			"def lis_length(nums, cmp=lambda x, y: x > y):",
			"    P = [0] * len(nums)",
			"    M = [0] * (len(nums) + 1)",
			"    L = 0",
			"",
			"    for i in range(len(nums)):",
			"        lo, hi = 1, L",
			"",
			"        while lo <= hi:",
			"            mid = (lo + hi) // 2",
			"            if cmp(nums[M[mid]], nums[i]):",
			"                lo = mid + 1",
			"            else:",
			"                hi = mid - 1",
			"",
			"        newL = lo",
			"        P[i] = M[newL - 1]",
			"        M[newL] = i",
			"",
			"        L = max(L, newL)",
			"",
			"    lislen=[1 for i in P]",
			"    for i in range(1,len(nums)):",
			"        if P[i]==0:",
			"            if cmp(nums[P[i]],nums[i]):",
			"                lislen[i]=lislen[P[i]]+1",
			"            else:",
			"                lislen[i]=lislen[P[i]]",
			"        else:",
			"            lislen[i] = lislen[P[i]] + 1",
			"    return lislen"
		],
		"description": "lis_length"
	},
	"32bitdecorators": {
		"prefix": "32bitdecorators",
		"body": [
			"import __pypy__",
			"",
			"int_add = __pypy__.intop.int_add",
			"int_sub = __pypy__.intop.int_sub",
			"int_mul = __pypy__.intop.int_mul",
			"",
			"",
			"def make_mod_mul(mod=10**9 + 7):",
			"    fmod_inv = 1.0 / mod",
			"",
			"    def mod_mul(a, b, c=0):",
			"        res = int_sub(int_add(int_mul(a, b), c), int_mul(mod, int(fmod_inv * a * b + fmod_inv * c)))",
			"        if res >= mod:",
			"            return res - mod",
			"        elif res < 0:",
			"            return res + mod",
			"        else:",
			"            return res",
			"",
			"    return mod_mul",
			"",
			"",
			"mod_mul = make_mod_mul()",
			"",
			"",
			"def mod_pow(x, y):",
			"    if y == 0:",
			"        return 1",
			"    res = 1",
			"    while y > 1:",
			"        if y & 1 == 1:",
			"            res = mod_mul(res, x)",
			"        x = mod_mul(x, x)",
			"        y >>= 1",
			"    return mod_mul(res, x)"
		],
		"description": "32bitdecorators"
	},
	"ncr_pypy": {
		"prefix": "ncr_pypy",
		"body": [
			"def make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):",
			"    max_n = min(max_n, mod - 1)",
			" ",
			"    fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)",
			"    fact[0] = 1",
			"    for i in range(max_n):",
			"        fact[i + 1] = fact[i] * (i + 1) % mod",
			" ",
			"    inv_fact[-1] = pow(fact[-1], mod - 2, mod)",
			"    for i in reversed(range(max_n)):",
			"        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod",
			" ",
			"    def nCr_mod(n, r):",
			"        res = 1",
			"        while n or r:",
			"            a, b = n % mod, r % mod",
			"            if a < b:",
			"                return 0",
			"            res = mod_mul(mod_mul(mod_mul(res, fact[a]), inv_fact[b]), inv_fact[a - b])",
			"            n //= mod",
			"            r //= mod",
			"        return res",
			" ",
			"    return nCr_mod"
		],
		"description": "ncr_pypy"
	},
	"binary_lifting": {
		"prefix": "binary_lifting",
		"body": [
			"class BinaryLifting:",
			"    def __init__(self,l,k,one_based=1):",
			"        \"\"\"l is an array from 0 to n-1 and one_based depends on l[i]\"\"\"",
			"        self.n=n=len(l)",
			"        self.maxn=maxn=k.bit_length()",
			"        self.dp = [[n for j in range(maxn)] for i in range(n + 1)]",
			"        for i in range(n):",
			"            self.dp[i + one_based][0] = l[i]",
			"        for theta in range(maxn-1):",
			"            for i in range(n):",
			"                par = self.dp[i + one_based][theta]",
			"                self.dp[i + one_based][theta + 1] = self.dp[par][theta]",
			"    def query(self,k,start=1):",
			"        \"\"\"start node in 1<=x<=n if one_based else 0<=x<n \"\"\"",
			"        for i in range(self.maxn):",
			"            theta = 1<<i",
			"            if k<theta:",
			"                break",
			"            if k & theta:",
			"                start = self.dp[start][i]",
			"        return start",
			"    def lca(self,a,b,heights):",
			"        diff=heights[a]-heights[b]",
			"        if diff>0:",
			"            a=self.query(diff,a)",
			"        elif diff<0:",
			"            b=self.query(-diff,b)",
			"        if a==b:",
			"            return a",
			"        for i in range(self.maxn-1,-1,-1):",
			"            if self.dp[a][i]!=self.dp[b][i]:",
			"                a=self.dp[a][i]",
			"                b=self.dp[b][i]",
			"        return self.dp[a][0]"
		],
		"description": "binary_lifting"
	},
	"lca_order_1": {
		"prefix": "lca_order_1",
		"body": [
			"class RangeQuery:",
			"    def __init__(self, data, func=min,default=0):",
			"        self.func = func",
			"        self._data = _data = [list(data)]",
			"        self.defualt=default",
			"        i, n = 1, len(_data[0])",
			"        while 2 * i <= n:",
			"            prev = _data[-1]",
			"            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])",
			"            i <<= 1",
			"        self.bit_len=[0 for i in range(n+1)]",
			"        for i in range(1,n+1):",
			"            self.bit_len[i]=self.bit_len[i//2]+1",
			"",
			"    def query_normal(self,start,stop):",
			"        \"\"\"func of data[start, stop) for mutable\"\"\"",
			"        ans=self.defualt",
			"        for j in range(self.bit_len[stop-start]-1,-1,-1):",
			"            if (1<<j)<=stop-start:",
			"                ans=self.func(ans,self._data[j][start])",
			"                start+=(1<<j)",
			"        return ans",
			"",
			"    def query(self, start, stop):",
			"        \"\"\"func of data[start, stop)\"\"\"",
			"        depth = self.bit_len[stop - start] - 1",
			"        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])",
			"",
			"    def __getitem__(self, idx):",
			"        return self._data[0][idx]",
			"class LCA:",
			"    def __init__(self, root, graph):",
			"        self.time = [-1] * len(graph)",
			"        self.path = [-1] * len(graph)",
			"        self.distance = [0] * len(graph)",
			"        P = [-1] * len(graph)",
			"        t = -1",
			"        dfs = [(root, 0)]",
			"        while dfs:",
			"            node, d = dfs.pop()",
			"            self.distance[node] = d",
			"            self.path[t] = P[node]",
			"            self.time[node] = t = t + 1",
			"            for nei in graph[node]:",
			"                if self.time[nei] == -1:",
			"                    P[nei] = node",
			"                    dfs.append((nei, d + 1))",
			"        self.rmq = RangeQuery(self.time[node] for node in self.path)",
			"",
			"    def __call__(self, a, b):",
			"        if a == b:",
			"            return a",
			"        a = self.time[a]",
			"        b = self.time[b]",
			"        if a > b:",
			"            a, b = b, a",
			"        return self.path[self.rmq.query(a, b)]"
		],
		"description": "lca_order_1"
	},
	"Toposort": {
		"prefix": "Toposort",
		"body": [
			"def toposort(graph):",
			"    res, found = [], [0] * len(graph)",
			"    stack = list(range(len(graph)))",
			"    while stack:",
			"        node = stack.pop()",
			"        if node < 0:",
			"            res.append(~node)",
			"        elif not found[node]:",
			"            found[node] = 1",
			"            stack.append(~node)",
			"            stack += graph[node]",
			"",
			"    # cycle check",
			"    for node in res:",
			"        if any(found[nei] for nei in graph[node]):",
			"            return None",
			"        found[node] = 0",
			"",
			"    return res[::-1]"
		],
		"description": "Toposort"
	},
	"unionfind defaultdict": {
		"prefix": "unionfind defaultdict",
		"body": [
			"class UnionFind:",
			"    def __init__(self, l=[]):",
			"        self.parent = dict()",
			"        for i in l:",
			"            self.add(i)",
			"    def add(self,a):",
			"        if a not in self.parent:",
			"            self.parent[a]=a",
			"    def find(self, a):",
			"        acopy = a",
			"        while a != self.parent[a]:",
			"            a = self.parent[a]",
			"        while acopy != a:",
			"            self.parent[acopy], acopy = a, self.parent[acopy]",
			"        return a",
			"",
			"    def union(self, a, b):",
			"        self.parent[self.find(b)] = self.find(a)"
		],
		"description": "unionfind defaultdict"
	},
	"unionfind": {
		"prefix": "unionfind",
		"body": [
			"class UnionFind:",
			"    def __init__(self, n):",
			"        self.parent = list(range(n))",
			"",
			"    def find(self, a):",
			"        acopy = a",
			"        while a != self.parent[a]:",
			"            a = self.parent[a]",
			"        while acopy != a:",
			"            self.parent[acopy], acopy = a, self.parent[acopy]",
			"        return a",
			"",
			"    def union(self, a, b):",
			"        self.parent[self.find(b)] = self.find(a)"
		],
		"description": "unionfind"
	},
	"libraries": {
		"prefix": "libraries",
		"body": [
			"from collections import defaultdict, Counter,deque",
			"from math import sqrt, log10, log, floor, factorial",
			"from bisect import bisect_left, bisect_right",
			"from itertools import permutations,combinations"
		],
		"description": "libraries"
	},
	"palindrome_dp": {
		"prefix": "palindrome_dp",
		"body": [
			"def palind_dp(s):",
			"    n=len(s)",
			"    dp=[[0 for i in range(n+1)] for j in range(n+1)]",
			"    for i in range(n):",
			"        iter1=i",
			"        iter2=i",
			"        while iter1>=0 and iter2<n and s[iter1]==s[iter2]:",
			"            dp[iter1][iter2+1]=1",
			"            iter1-=1",
			"            iter2+=1",
			"        iter1=i",
			"        iter2=i+1",
			"        while iter1>=0 and iter2<n and s[iter1]==s[iter2]:",
			"            dp[iter1][iter2+1]=1",
			"            iter1-=1",
			"            iter2+=1",
			"",
			"    return dp"
		],
		"description": "palindrome_dp"
	},
	"cmp_to_key": {
		"prefix": "cmp_to_key",
		"body": [
			"from functools import cmp_to_key",
			"def fun(a,b):",
			"    if a%2==b%2:",
			"        return 0",
			"    return a-b"
		],
		"description": "cmp_to_key"
	},
	"LCSubstr": {
		"prefix": "LCSubstr",
		"body": [
			"from difflib import SequenceMatcher",
			"LCSubstr = lambda a, b: SequenceMatcher(None, a, b).find_longest_match(0, len(a), 0, len(b))"
		],
		"description": "LCSubstr"
	},
	"multi_source_bfs": {
		"prefix": "multi_source_bfs",
		"body": [
			"def bfs(mat,graph,monster,monster_value=0):",
			"    n = len(mat)",
			"    m = len(mat[0])",
			"    ans = [[0 for i in range(m)] for j in range(n)]",
			"    visited=defaultdict(int)",
			"    q = deque()",
			"    for i in range(n):",
			"        for j in range(m):",
			"            if mat[i][j] == monster:",
			"                q.append((i, j))",
			"                visited[(i,j)]=1",
			"                ans[i][j]=monster_value",
			"    while q:",
			"        s=q.popleft()",
			"        for i in graph[s[0]][s[1]]:",
			"            if visited[i]==0:",
			"                q.append(i)",
			"                visited[i] = 1",
			"                ans[i[0]][i[1]]=ans[s[0]][s[1]]+1",
			"    return ans",
			"def adj(i,j):",
			"    return ((i,j+1),(i+1,j))",
			"def multi_source_bfs(mat):",
			"    n=len(mat)",
			"    m=len(mat[0])",
			"    graph=[[[] for i in range(m)] for j in range(n)]",
			"    for i in range(n):",
			"        for j in range(m):",
			"            for t1,t2 in adj(i,j):",
			"                if t1<n and t2<m:",
			"                    graph[i][j].append((t1,t2))",
			"                    graph[t1][t2].append((i,j))",
			"    return bfs(mat,graph,0)"
		],
		"description": "multi_source_bfs"
	},
	"maximum_len_square_matrix": {
		"prefix": "maximum_len_square_matrix",
		"body": [
			"def maximum_len_square_matrix(mat,num=1):",
			"    n=len(mat)",
			"    m=len(mat[0])",
			"    maxa=0",
			"    for i in range(n):",
			"        for j in range(m):",
			"            if i==0 or j==0:",
			"                if mat[i][j]==num:",
			"                    mat[i][j]=1",
			"                else:",
			"                    mat[i][j]=0",
			"            elif mat[i][j]!=num:",
			"                mat[i][j]=0",
			"            else:",
			"                mat[i][j]=min(mat[i-1][j],mat[i-1][j-1],mat[i][j-1])+1",
			"",
			"            maxa=max(maxa,mat[i][j])",
			"    return maxa"
		],
		"description": "maximum_len_square_matrix"
	},
	"fastio template pypy2": {
		"prefix": "fastio template pypy2",
		"body": [
			"#!/usr/bin/env pypy",
			"from __future__ import division, print_function",
			"",
			"import os",
			"import sys",
			"from __builtin__ import xrange as range",
			"from cStringIO import StringIO",
			"from future_builtins import ascii, filter, hex, map, oct, zip",
			"from io import IOBase",
			"",
			"import __pypy__",
			"",
			"# region fastio",
			"",
			"BUFSIZE = 8192",
			"",
			"",
			"class FastI(IOBase):",
			"    def __init__(self, file):",
			"        self._fd = file.fileno()",
			"        self._buffer = StringIO()",
			"        self.newlines = 0",
			"",
			"    def read(self):",
			"        while True:",
			"            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
			"            if not b:",
			"                break",
			"            ptr = self.buffer.tell()",
			"            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
			"        self.newlines = 0",
			"        return self.buffer.read()",
			"",
			"    def readline(self):",
			"        while self.newlines == 0:",
			"            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
			"            self.newlines = b.count(\"\\n\") + (not b)",
			"            ptr = self._buffer.tell()",
			"            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)",
			"        self.newlines -= 1",
			"        return self._buffer.readline()",
			"",
			"",
			"class FastO(IOBase):",
			"    def __init__(self, file):",
			"        self._fd = file.fileno()",
			"        self._buffer = __pypy__.builders.StringBuilder()",
			"        self.write = lambda s: self._buffer.append(s)",
			"",
			"    def flush(self):",
			"        os.write(self._fd, self._buffer.build())",
			"        self._buffer = __pypy__.builders.StringBuilder()",
			"",
			"",
			"def print(*args, **kwargs):",
			"    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)",
			"    at_start = True",
			"    for x in args:",
			"        if not at_start:",
			"            file.write(sep)",
			"        file.write(str(x))",
			"        at_start = False",
			"    file.write(kwargs.pop(\"end\", \"\\n\"))",
			"    if kwargs.pop(\"flush\", False):",
			"        file.flush()",
			"",
			"",
			"sys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)",
			"input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")"
		],
		"description": "fastio template pypy2"
	},
	"prime_factors": {
		"prefix": "prime_factors",
		"body": [
			"def prime_factors(n):",
			"    l = []",
			"    while n % 2 == 0:",
			"        l.append(2)",
			"        n //= 2",
			"    sqrta = int(sqrt(n))",
			"",
			"    for i in range(3, sqrta + 1, 2):",
			"        while n % i == 0:",
			"            n //= i",
			"            l.append(i)",
			"    if n > 2:",
			"        l.append(n)",
			"    return l"
		],
		"description": "prime_factors"
	},
	"infinite recursion": {
		"prefix": "recursion",
		"body": [
			"from types import GeneratorType",
			"",
			"",
			"def bootstrap(f, stack=[]):",
			"    def wrappedfunc(*args, **kwargs):",
			"        if stack:",
			"            return f(*args, **kwargs)",
			"        else:",
			"            to = f(*args, **kwargs)",
			"            while True:",
			"                if type(to) is GeneratorType:",
			"                    stack.append(to)",
			"                    to = next(to)",
			"                else:",
			"                    stack.pop()",
			"                    if not stack:",
			"                        break",
			"                    to = stack[-1].send(to)",
			"            return to",
			"",
			"    return wrappedfunc",
			"# @bootstrap",
			"# def fun(n):",
			"#     if n==0:",
			"#         yield",
			"#     yield fun(n-1)",
			"#     print(n)",
			"#     yield",
			"# ",
			"# fun(1000000)"
		],
		"description": "infinite recursion"
	},
	"lazy segment tree": {
		"prefix": "lazy segment tree",
		"body": [
			"class LazySegmentTree:",
			"    def __init__(self, data, default=0, func=max):",
			"        \"\"\"initialize the lazy segment tree with data\"\"\"",
			"        self._default = default",
			"        self._func = func",
			"",
			"        self._len = len(data)",
			"        self._size = _size = 1 << (self._len - 1).bit_length()",
			"        self._lazy = [0] * (2 * _size)",
			"",
			"        self.data = [default] * (2 * _size)",
			"        self.data[_size:_size + self._len] = data",
			"        for i in reversed(range(_size)):",
			"            self.data[i] = func(self.data[i + i], self.data[i + i + 1])",
			"",
			"    def __len__(self):",
			"        return self._len",
			"",
			"    def _push(self, idx):",
			"        \"\"\"push query on idx to its children\"\"\"",
			"        # Let the children know of the queries",
			"        q, self._lazy[idx] = self._lazy[idx], 0",
			"",
			"        self._lazy[2 * idx] += q",
			"        self._lazy[2 * idx + 1] += q",
			"        self.data[2 * idx] += q",
			"        self.data[2 * idx + 1] += q",
			"",
			"    def _update(self, idx):",
			"        \"\"\"updates the node idx to know of all queries applied to it via its ancestors\"\"\"",
			"        for i in reversed(range(1, idx.bit_length())):",
			"            self._push(idx >> i)",
			"",
			"    def _build(self, idx):",
			"        \"\"\"make the changes to idx be known to its ancestors\"\"\"",
			"        idx >>= 1",
			"        while idx:",
			"            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1]) + self._lazy[idx]",
			"            idx >>= 1",
			"",
			"    def add(self, start, stop, value):",
			"        \"\"\"lazily add value to [start, stop)\"\"\"",
			"        start = start_copy = start + self._size",
			"        stop = stop_copy = stop + self._size",
			"        while start < stop:",
			"            if start & 1:",
			"                self._lazy[start] += value",
			"                self.data[start] += value",
			"                start += 1",
			"            if stop & 1:",
			"                stop -= 1",
			"                self._lazy[stop] += value",
			"                self.data[stop] += value",
			"            start >>= 1",
			"            stop >>= 1",
			"",
			"        # Tell all nodes above of the updated area of the updates",
			"        self._build(start_copy)",
			"        self._build(stop_copy - 1)",
			"",
			"    def query(self, start, stop, default=0):",
			"        \"\"\"func of data[start, stop)\"\"\"",
			"        start += self._size",
			"        stop += self._size",
			"",
			"        # Apply all the lazily stored queries",
			"        self._update(start)",
			"        self._update(stop - 1)",
			"",
			"        res = default",
			"        while start < stop:",
			"            if start & 1:",
			"                res = self._func(res, self.data[start])",
			"                start += 1",
			"            if stop & 1:",
			"                stop -= 1",
			"                res = self._func(res, self.data[stop])",
			"            start >>= 1",
			"            stop >>= 1",
			"        return res",
			"",
			"    def __repr__(self):",
			"        return \"LazySegmentTree({0})\".format(self.data)"
		],
		"description": "lazy segment tree"
	},
	"segment tree": {
		"prefix": "segment tree",
		"body": [
			"class SegmentTree:",
			"    def __init__(self, data, default=0, func=max):",
			"        \"\"\"initialize the segment tree with data\"\"\"",
			"        self._default = default",
			"        self._func = func",
			"        self._len = len(data)",
			"        self._size = _size = 1 << (self._len - 1).bit_length()",
			" ",
			"        self.data = [default] * (2 * _size)",
			"        self.data[_size:_size + self._len] = data",
			"        for i in reversed(range(_size)):",
			"            self.data[i] = func(self.data[i + i], self.data[i + i + 1])",
			" ",
			"    def __delitem__(self, idx):",
			"        self[idx] = self._default",
			" ",
			"    def __getitem__(self, idx):",
			"        return self.data[idx + self._size]",
			" ",
			"    def __setitem__(self, idx, value):",
			"        idx += self._size",
			"        self.data[idx] = value",
			"        idx >>= 1",
			"        while idx:",
			"            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])",
			"            idx >>= 1",
			" ",
			"    def __len__(self):",
			"        return self._len",
			" ",
			"    def query(self, start, stop):",
			"        \"\"\"func of data[start, stop)\"\"\"",
			"        start += self._size",
			"        stop += self._size",
			" ",
			"        res_left = res_right = self._default",
			"        while start < stop:",
			"            if start & 1:",
			"                res_left = self._func(res_left, self.data[start])",
			"                start += 1",
			"            if stop & 1:",
			"                stop -= 1",
			"                res_right = self._func(self.data[stop], res_right)",
			"            start >>= 1",
			"            stop >>= 1",
			" ",
			"        return self._func(res_left, res_right)",
			" ",
			"    def __repr__(self):",
			"        return \"SegmentTree({0})\".format(self.data)"
		],
		"description": "segment tree"
	},
	"bitset": {
		"prefix": "bitset",
		"body": [
			"class BitArray:",
			"    \"\"\"implements bitarray using bytearray\"\"\"",
			"    def __init__(self, size):",
			"        self.bytes = bytearray((size >> 3) + 1)",
			"",
			"    def __getitem__(self, index):",
			"        return (self.bytes[index >> 3] >> (index & 7)) & 1",
			"",
			"    def __setitem__(self, index, value):",
			"        if value:",
			"            self.bytes[index >> 3] |= 1 << (index & 7)",
			"        else:",
			"            self.bytes[index >> 3] &= ~(1 << (index & 7))"
		],
		"description": "bitset"
	},
	"disjoint set union": {
		"prefix": "disjoint set union",
		"body": [
			"class DisjointSetUnion:",
			"    def __init__(self, n):",
			"        self.parent = list(range(n))",
			"        self.size = [1] * n",
			"        self.num_sets = n",
			"",
			"    def find(self, a):",
			"        acopy = a",
			"        while a != self.parent[a]:",
			"            a = self.parent[a]",
			"        while acopy != a:",
			"            self.parent[acopy], acopy = a, self.parent[acopy]",
			"        return a",
			"",
			"    def union(self, a, b):",
			"        a, b = self.find(a), self.find(b)",
			"        if a != b:",
			"            if self.size[a] < self.size[b]:",
			"                a, b = b, a",
			"",
			"            self.num_sets -= 1",
			"            self.parent[b] = a",
			"            self.size[a] += self.size[b]",
			"            return 1",
			"        return 0",
			"",
			"    def set_size(self, a):",
			"        return self.size[self.find(a)]",
			"",
			"    def __len__(self):",
			"        return self.num_sets"
		],
		"description": "disjoint set union"
	},
	"disjoint set": {
		"prefix": "disjoint set",
		"body": [
			"class DisjointSetUnion:",
			"    def __init__(self, n):",
			"        self.parent = list(range(n))",
			"        self.size = [1] * n",
			"        self.num_sets = n",
			"",
			"    def find(self, a):",
			"        acopy = a",
			"        while a != self.parent[a]:",
			"            a = self.parent[a]",
			"        while acopy != a:",
			"            self.parent[acopy], acopy = a, self.parent[acopy]",
			"        return a",
			"",
			"    def union(self, a, b):",
			"        a, b = self.find(a), self.find(b)",
			"        if a != b:",
			"            if self.size[a] < self.size[b]:",
			"                a, b = b, a",
			"",
			"            self.num_sets -= 1",
			"            self.parent[b] = a",
			"            self.size[a] += self.size[b]",
			"",
			"    def set_size(self, a):",
			"        return self.size[self.find(a)]",
			"",
			"    def __len__(self):",
			"        return self.num_sets",
			"",
			"",
			"class UnionFind:",
			"    def __init__(self, n):",
			"        self.parent = list(range(n))",
			"",
			"    def find(self, a):",
			"        acopy = a",
			"        while a != self.parent[a]:",
			"            a = self.parent[a]",
			"        while acopy != a:",
			"            self.parent[acopy], acopy = a, self.parent[acopy]",
			"        return a",
			"",
			"    def union(self, a, b):",
			"        self.parent[self.find(b)] = self.find(a)"
		],
		"description": "disjoint set"
	},
	"discrete binary search": {
		"prefix": "discrete binary search",
		"body": [
			"def discrete_binary_search(func, lo, hi):",
			"    \"\"\" Locate the first value x s.t. func(x) = True within [lo, hi] \"\"\"",
			"    while lo < hi:",
			"        mi = lo + (hi - lo) // 2",
			"        if func(mi):",
			"            hi = mi",
			"        else:",
			"            lo = mi + 1",
			"",
			"    return lo"
		],
		"description": "discrete binary search"
	},
	"RabinKarp": {
		"prefix": "RabinKarp",
		"body": [
			"class RabinKarp:",
			"    def __init__(self,s,k,p=10**9+7,d=26):",
			"        hash=0",
			"        self.pow=pow(d,k-1,p)",
			"        self.hashlist=[0 for i in range(len(s))]",
			"        for i in range(k):",
			"            hash=(hash*d+s[i])%p",
			"            self.hashlist[i]=hash",
			"        for i in range(k,len(s)):",
			"            hash=(d*(hash-s[i-k]*self.pow)+s[i])%p",
			"            self.hashlist[i]=hash",
			"    def query(self,start,k):",
			"        return self.hashlist[start+k-1]",
			"    def samestring(self,s,i,j,k):",
			"        for counter in range(k):",
			"            if s[i+counter]!=s[j+counter]:",
			"                return 0",
			"        return 1"
		],
		"description": "RabinKarp"
	},
	"discrete binary search upper": {
		"prefix": "discrete binary search upper",
		"body": [
			"def discrete_binary_search_upper(func, lo, hi):",
			"    \"\"\" Locate the last value x s.t. func(x) = False within [lo, hi] \"\"\"",
			"    while lo < hi:",
			"        mi = lo + (hi - lo + 1) // 2",
			"        if func(mi):",
			"            hi = mi - 1",
			"        else:",
			"            lo = mi",
			"",
			"    return lo"
		],
		"description": "discrete binary search upper"
	},
	"count inversion": {
		"prefix": "inversion count",
		"body": [
			"class SortedList:",
			"    def __init__(self, iterable=[], _load=200):",
			"        \"\"\"Initialize sorted list instance.\"\"\"",
			"        values = sorted(iterable)",
			"        self._len = _len = len(values)",
			"        self._load = _load",
			"        self._lists = _lists = [values[i:i + _load]",
			"                                for i in range(0, _len, _load)]",
			"        self._list_lens = [len(_list) for _list in _lists]",
			"        self._mins = [_list[0] for _list in _lists]",
			"        self._fen_tree = []",
			"        self._rebuild = True",
			"",
			"    def _fen_build(self):",
			"        \"\"\"Build a fenwick tree instance.\"\"\"",
			"        self._fen_tree[:] = self._list_lens",
			"        _fen_tree = self._fen_tree",
			"        for i in range(len(_fen_tree)):",
			"            if i | i + 1 < len(_fen_tree):",
			"                _fen_tree[i | i + 1] += _fen_tree[i]",
			"        self._rebuild = False",
			"",
			"    def _fen_update(self, index, value):",
			"        \"\"\"Update `fen_tree[index] += value`.\"\"\"",
			"        if not self._rebuild:",
			"            _fen_tree = self._fen_tree",
			"            while index < len(_fen_tree):",
			"                _fen_tree[index] += value",
			"                index |= index + 1",
			"",
			"    def _fen_query(self, end):",
			"        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"",
			"        if self._rebuild:",
			"            self._fen_build()",
			"",
			"        _fen_tree = self._fen_tree",
			"        x = 0",
			"        while end:",
			"            x += _fen_tree[end - 1]",
			"            end &= end - 1",
			"        return x",
			"",
			"    def _fen_findkth(self, k):",
			"        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"",
			"        _list_lens = self._list_lens",
			"        if k < _list_lens[0]:",
			"            return 0, k",
			"        if k >= self._len - _list_lens[-1]:",
			"            return len(_list_lens) - 1, k + _list_lens[-1] - self._len",
			"        if self._rebuild:",
			"            self._fen_build()",
			"",
			"        _fen_tree = self._fen_tree",
			"        idx = -1",
			"        for d in reversed(range(len(_fen_tree).bit_length())):",
			"            right_idx = idx + (1 << d)",
			"            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:",
			"                idx = right_idx",
			"                k -= _fen_tree[idx]",
			"        return idx + 1, k",
			"",
			"    def _delete(self, pos, idx):",
			"        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"        _list_lens = self._list_lens",
			"",
			"        self._len -= 1",
			"        self._fen_update(pos, -1)",
			"        del _lists[pos][idx]",
			"        _list_lens[pos] -= 1",
			"",
			"        if _list_lens[pos]:",
			"            _mins[pos] = _lists[pos][0]",
			"        else:",
			"            del _lists[pos]",
			"            del _list_lens[pos]",
			"            del _mins[pos]",
			"            self._rebuild = True",
			"",
			"    def _loc_left(self, value):",
			"        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"",
			"        if not self._len:",
			"            return 0, 0",
			"",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"",
			"        lo, pos = -1, len(_lists) - 1",
			"        while lo + 1 < pos:",
			"            mi = (lo + pos) >> 1",
			"            if value <= _mins[mi]:",
			"                pos = mi",
			"            else:",
			"                lo = mi",
			"",
			"        if pos and value <= _lists[pos - 1][-1]:",
			"            pos -= 1",
			"",
			"        _list = _lists[pos]",
			"        lo, idx = -1, len(_list)",
			"        while lo + 1 < idx:",
			"            mi = (lo + idx) >> 1",
			"            if value <= _list[mi]:",
			"                idx = mi",
			"            else:",
			"                lo = mi",
			"",
			"        return pos, idx",
			"",
			"    def _loc_right(self, value):",
			"        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"",
			"        if not self._len:",
			"            return 0, 0",
			"",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"",
			"        pos, hi = 0, len(_lists)",
			"        while pos + 1 < hi:",
			"            mi = (pos + hi) >> 1",
			"            if value < _mins[mi]:",
			"                hi = mi",
			"            else:",
			"                pos = mi",
			"",
			"        _list = _lists[pos]",
			"        lo, idx = -1, len(_list)",
			"        while lo + 1 < idx:",
			"            mi = (lo + idx) >> 1",
			"            if value < _list[mi]:",
			"                idx = mi",
			"            else:",
			"                lo = mi",
			"",
			"        return pos, idx",
			"",
			"    def add(self, value):",
			"        \"\"\"Add `value` to sorted list.\"\"\"",
			"        _load = self._load",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"        _list_lens = self._list_lens",
			"",
			"        self._len += 1",
			"        if _lists:",
			"            pos, idx = self._loc_right(value)",
			"            self._fen_update(pos, 1)",
			"            _list = _lists[pos]",
			"            _list.insert(idx, value)",
			"            _list_lens[pos] += 1",
			"            _mins[pos] = _list[0]",
			"            if _load + _load < len(_list):",
			"                _lists.insert(pos + 1, _list[_load:])",
			"                _list_lens.insert(pos + 1, len(_list) - _load)",
			"                _mins.insert(pos + 1, _list[_load])",
			"                _list_lens[pos] = _load",
			"                del _list[_load:]",
			"                self._rebuild = True",
			"        else:",
			"            _lists.append([value])",
			"            _mins.append(value)",
			"            _list_lens.append(1)",
			"            self._rebuild = True",
			"",
			"    def discard(self, value):",
			"        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"",
			"        _lists = self._lists",
			"        if _lists:",
			"            pos, idx = self._loc_right(value)",
			"            if idx and _lists[pos][idx - 1] == value:",
			"                self._delete(pos, idx - 1)",
			"",
			"    def remove(self, value):",
			"        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"",
			"        _len = self._len",
			"        self.discard(value)",
			"        if _len == self._len:",
			"            raise ValueError('{0!r} not in list'.format(value))",
			"",
			"    def pop(self, index=-1):",
			"        \"\"\"Remove and return value at `index` in sorted list.\"\"\"",
			"        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
			"        value = self._lists[pos][idx]",
			"        self._delete(pos, idx)",
			"        return value",
			"",
			"    def bisect_left(self, value):",
			"        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"",
			"        pos, idx = self._loc_left(value)",
			"        return self._fen_query(pos) + idx",
			"",
			"    def bisect_right(self, value):",
			"        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"",
			"        pos, idx = self._loc_right(value)",
			"        return self._fen_query(pos) + idx",
			"",
			"    def count(self, value):",
			"        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"",
			"        return self.bisect_right(value) - self.bisect_left(value)",
			"",
			"    def __len__(self):",
			"        \"\"\"Return the size of the sorted list.\"\"\"",
			"        return self._len",
			"",
			"    def __getitem__(self, index):",
			"        \"\"\"Lookup value at `index` in sorted list.\"\"\"",
			"        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
			"        return self._lists[pos][idx]",
			"",
			"    def __delitem__(self, index):",
			"        \"\"\"Remove value at `index` from sorted list.\"\"\"",
			"        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
			"        self._delete(pos, idx)",
			"",
			"    def __contains__(self, value):",
			"        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"",
			"        _lists = self._lists",
			"        if _lists:",
			"            pos, idx = self._loc_left(value)",
			"            return idx < len(_lists[pos]) and _lists[pos][idx] == value",
			"        return False",
			"",
			"    def __iter__(self):",
			"        \"\"\"Return an iterator over the sorted list.\"\"\"",
			"        return (value for _list in self._lists for value in _list)",
			"",
			"    def __reversed__(self):",
			"        \"\"\"Return a reverse iterator over the sorted list.\"\"\"",
			"        return (value for _list in reversed(self._lists) for value in reversed(_list))",
			"",
			"    def __repr__(self):",
			"        \"\"\"Return string representation of sorted list.\"\"\"",
			"        return 'SortedList({0})'.format(list(self))",
			"",
			"",
			"def inversion_count(arr):",
			"    s = SortedList()",
			"    counter = 0",
			"    for i in reversed(arr):",
			"        s.add(i)",
			"        counter += s.bisect_left(i)",
			"    return counter",
			""
		],
		"description": "count inversion"
	},
	"sortedlist": {
		"prefix": "sortedlist",
		"body": [
			"class SortedList:",
			"    def __init__(self, iterable=[], _load=200):",
			"        \"\"\"Initialize sorted list instance.\"\"\"",
			"        values = sorted(iterable)",
			"        self._len = _len = len(values)",
			"        self._load = _load",
			"        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]",
			"        self._list_lens = [len(_list) for _list in _lists]",
			"        self._mins = [_list[0] for _list in _lists]",
			"        self._fen_tree = []",
			"        self._rebuild = True",
			" ",
			"    def _fen_build(self):",
			"        \"\"\"Build a fenwick tree instance.\"\"\"",
			"        self._fen_tree[:] = self._list_lens",
			"        _fen_tree = self._fen_tree",
			"        for i in range(len(_fen_tree)):",
			"            if i | i + 1 < len(_fen_tree):",
			"                _fen_tree[i | i + 1] += _fen_tree[i]",
			"        self._rebuild = False",
			" ",
			"    def _fen_update(self, index, value):",
			"        \"\"\"Update `fen_tree[index] += value`.\"\"\"",
			"        if not self._rebuild:",
			"            _fen_tree = self._fen_tree",
			"            while index < len(_fen_tree):",
			"                _fen_tree[index] += value",
			"                index |= index + 1",
			" ",
			"    def _fen_query(self, end):",
			"        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"",
			"        if self._rebuild:",
			"            self._fen_build()",
			" ",
			"        _fen_tree = self._fen_tree",
			"        x = 0",
			"        while end:",
			"            x += _fen_tree[end - 1]",
			"            end &= end - 1",
			"        return x",
			" ",
			"    def _fen_findkth(self, k):",
			"        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"",
			"        _list_lens = self._list_lens",
			"        if k < _list_lens[0]:",
			"            return 0, k",
			"        if k >= self._len - _list_lens[-1]:",
			"            return len(_list_lens) - 1, k + _list_lens[-1] - self._len",
			"        if self._rebuild:",
			"            self._fen_build()",
			" ",
			"        _fen_tree = self._fen_tree",
			"        idx = -1",
			"        for d in reversed(range(len(_fen_tree).bit_length())):",
			"            right_idx = idx + (1 << d)",
			"            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:",
			"                idx = right_idx",
			"                k -= _fen_tree[idx]",
			"        return idx + 1, k",
			" ",
			"    def _delete(self, pos, idx):",
			"        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"        _list_lens = self._list_lens",
			" ",
			"        self._len -= 1",
			"        self._fen_update(pos, -1)",
			"        del _lists[pos][idx]",
			"        _list_lens[pos] -= 1",
			" ",
			"        if _list_lens[pos]:",
			"            _mins[pos] = _lists[pos][0]",
			"        else:",
			"            del _lists[pos]",
			"            del _list_lens[pos]",
			"            del _mins[pos]",
			"            self._rebuild = True",
			" ",
			"    def _loc_left(self, value):",
			"        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"",
			"        if not self._len:",
			"            return 0, 0",
			" ",
			"        _lists = self._lists",
			"        _mins = self._mins",
			" ",
			"        lo, pos = -1, len(_lists) - 1",
			"        while lo + 1 < pos:",
			"            mi = (lo + pos) >> 1",
			"            if value <= _mins[mi]:",
			"                pos = mi",
			"            else:",
			"                lo = mi",
			" ",
			"        if pos and value <= _lists[pos - 1][-1]:",
			"            pos -= 1",
			" ",
			"        _list = _lists[pos]",
			"        lo, idx = -1, len(_list)",
			"        while lo + 1 < idx:",
			"            mi = (lo + idx) >> 1",
			"            if value <= _list[mi]:",
			"                idx = mi",
			"            else:",
			"                lo = mi",
			" ",
			"        return pos, idx",
			" ",
			"    def _loc_right(self, value):",
			"        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"",
			"        if not self._len:",
			"            return 0, 0",
			" ",
			"        _lists = self._lists",
			"        _mins = self._mins",
			" ",
			"        pos, hi = 0, len(_lists)",
			"        while pos + 1 < hi:",
			"            mi = (pos + hi) >> 1",
			"            if value < _mins[mi]:",
			"                hi = mi",
			"            else:",
			"                pos = mi",
			" ",
			"        _list = _lists[pos]",
			"        lo, idx = -1, len(_list)",
			"        while lo + 1 < idx:",
			"            mi = (lo + idx) >> 1",
			"            if value < _list[mi]:",
			"                idx = mi",
			"            else:",
			"                lo = mi",
			" ",
			"        return pos, idx",
			" ",
			"    def add(self, value):",
			"        \"\"\"Add `value` to sorted list.\"\"\"",
			"        _load = self._load",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"        _list_lens = self._list_lens",
			" ",
			"        self._len += 1",
			"        if _lists:",
			"            pos, idx = self._loc_right(value)",
			"            self._fen_update(pos, 1)",
			"            _list = _lists[pos]",
			"            _list.insert(idx, value)",
			"            _list_lens[pos] += 1",
			"            _mins[pos] = _list[0]",
			"            if _load + _load < len(_list):",
			"                _lists.insert(pos + 1, _list[_load:])",
			"                _list_lens.insert(pos + 1, len(_list) - _load)",
			"                _mins.insert(pos + 1, _list[_load])",
			"                _list_lens[pos] = _load",
			"                del _list[_load:]",
			"                self._rebuild = True",
			"        else:",
			"            _lists.append([value])",
			"            _mins.append(value)",
			"            _list_lens.append(1)",
			"            self._rebuild = True",
			" ",
			"    def discard(self, value):",
			"        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"",
			"        _lists = self._lists",
			"        if _lists:",
			"            pos, idx = self._loc_right(value)",
			"            if idx and _lists[pos][idx - 1] == value:",
			"                self._delete(pos, idx - 1)",
			" ",
			"    def remove(self, value):",
			"        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"",
			"        _len = self._len",
			"        self.discard(value)",
			"        if _len == self._len:",
			"            raise ValueError('{0!r} not in list'.format(value))",
			" ",
			"    def pop(self, index=-1):",
			"        \"\"\"Remove and return value at `index` in sorted list.\"\"\"",
			"        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
			"        value = self._lists[pos][idx]",
			"        self._delete(pos, idx)",
			"        return value",
			" ",
			"    def bisect_left(self, value):",
			"        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"",
			"        pos, idx = self._loc_left(value)",
			"        return self._fen_query(pos) + idx",
			" ",
			"    def bisect_right(self, value):",
			"        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"",
			"        pos, idx = self._loc_right(value)",
			"        return self._fen_query(pos) + idx",
			" ",
			"    def count(self, value):",
			"        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"",
			"        return self.bisect_right(value) - self.bisect_left(value)",
			" ",
			"    def __len__(self):",
			"        \"\"\"Return the size of the sorted list.\"\"\"",
			"        return self._len",
			" ",
			"    def __getitem__(self, index):",
			"        \"\"\"Lookup value at `index` in sorted list.\"\"\"",
			"        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
			"        return self._lists[pos][idx]",
			" ",
			"    def __delitem__(self, index):",
			"        \"\"\"Remove value at `index` from sorted list.\"\"\"",
			"        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
			"        self._delete(pos, idx)",
			" ",
			"    def __contains__(self, value):",
			"        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"",
			"        _lists = self._lists",
			"        if _lists:",
			"            pos, idx = self._loc_left(value)",
			"            return idx < len(_lists[pos]) and _lists[pos][idx] == value",
			"        return False",
			" ",
			"    def __iter__(self):",
			"        \"\"\"Return an iterator over the sorted list.\"\"\"",
			"        return (value for _list in self._lists for value in _list)",
			" ",
			"    def __reversed__(self):",
			"        \"\"\"Return a reverse iterator over the sorted list.\"\"\"",
			"        return (value for _list in reversed(self._lists) for value in reversed(_list))",
			" ",
			"    def __repr__(self):",
			"        \"\"\"Return string representation of sorted list.\"\"\"",
			"        return 'SortedList({0})'.format(list(self))"
		],
		"description": "sortedlist"
	},
	"sortedset": {
		"prefix": "sortedset",
		"body": [
			"class SortedSet:",
			"    def __init__(self, iterable=[], _load=200):",
			"        \"\"\"Initialize sorted list instance.\"\"\"",
			"        values = sorted(iterable)",
			"        self._len = _len = len(values)",
			"        self._load = _load",
			"        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]",
			"        self._list_lens = [len(_list) for _list in _lists]",
			"        self._mins = [_list[0] for _list in _lists]",
			"        self._fen_tree = []",
			"        self._rebuild = True",
			"",
			"    def _fen_build(self):",
			"        \"\"\"Build a fenwick tree instance.\"\"\"",
			"        self._fen_tree[:] = self._list_lens",
			"        _fen_tree = self._fen_tree",
			"        for i in range(len(_fen_tree)):",
			"            if i | i + 1 < len(_fen_tree):",
			"                _fen_tree[i | i + 1] += _fen_tree[i]",
			"        self._rebuild = False",
			"",
			"    def _fen_update(self, index, value):",
			"        \"\"\"Update `fen_tree[index] += value`.\"\"\"",
			"        if not self._rebuild:",
			"            _fen_tree = self._fen_tree",
			"            while index < len(_fen_tree):",
			"                _fen_tree[index] += value",
			"                index |= index + 1",
			"",
			"    def _fen_query(self, end):",
			"        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"",
			"        if self._rebuild:",
			"            self._fen_build()",
			"",
			"        _fen_tree = self._fen_tree",
			"        x = 0",
			"        while end:",
			"            x += _fen_tree[end - 1]",
			"            end &= end - 1",
			"        return x",
			"",
			"    def _fen_findkth(self, k):",
			"        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"",
			"        _list_lens = self._list_lens",
			"        if k < _list_lens[0]:",
			"            return 0, k",
			"        if k >= self._len - _list_lens[-1]:",
			"            return len(_list_lens) - 1, k + _list_lens[-1] - self._len",
			"        if self._rebuild:",
			"            self._fen_build()",
			"",
			"        _fen_tree = self._fen_tree",
			"        idx = -1",
			"        for d in reversed(range(len(_fen_tree).bit_length())):",
			"            right_idx = idx + (1 << d)",
			"            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:",
			"                idx = right_idx",
			"                k -= _fen_tree[idx]",
			"        return idx + 1, k",
			"",
			"    def _delete(self, pos, idx):",
			"        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"        _list_lens = self._list_lens",
			"",
			"        self._len -= 1",
			"        self._fen_update(pos, -1)",
			"        del _lists[pos][idx]",
			"        _list_lens[pos] -= 1",
			"",
			"        if _list_lens[pos]:",
			"            _mins[pos] = _lists[pos][0]",
			"        else:",
			"            del _lists[pos]",
			"            del _list_lens[pos]",
			"            del _mins[pos]",
			"            self._rebuild = True",
			"",
			"    def _loc_left(self, value):",
			"        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"",
			"        if not self._len:",
			"            return 0, 0",
			"",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"",
			"        lo, pos = -1, len(_lists) - 1",
			"        while lo + 1 < pos:",
			"            mi = (lo + pos) >> 1",
			"            if value <= _mins[mi]:",
			"                pos = mi",
			"            else:",
			"                lo = mi",
			"",
			"        if pos and value <= _lists[pos - 1][-1]:",
			"            pos -= 1",
			"",
			"        _list = _lists[pos]",
			"        lo, idx = -1, len(_list)",
			"        while lo + 1 < idx:",
			"            mi = (lo + idx) >> 1",
			"            if value <= _list[mi]:",
			"                idx = mi",
			"            else:",
			"                lo = mi",
			"",
			"        return pos, idx",
			"",
			"    def _loc_right(self, value):",
			"        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"",
			"        if not self._len:",
			"            return 0, 0",
			"",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"",
			"        pos, hi = 0, len(_lists)",
			"        while pos + 1 < hi:",
			"            mi = (pos + hi) >> 1",
			"            if value < _mins[mi]:",
			"                hi = mi",
			"            else:",
			"                pos = mi",
			"",
			"        _list = _lists[pos]",
			"        lo, idx = -1, len(_list)",
			"        while lo + 1 < idx:",
			"            mi = (lo + idx) >> 1",
			"            if value < _list[mi]:",
			"                idx = mi",
			"            else:",
			"                lo = mi",
			"",
			"        return pos, idx",
			"",
			"    def add(self, value):",
			"        \"\"\"Add `value` to sorted list.\"\"\"",
			"        if self.__contains__(value):",
			"            return",
			"        _load = self._load",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"        _list_lens = self._list_lens",
			"",
			"        self._len += 1",
			"        if _lists:",
			"            pos, idx = self._loc_right(value)",
			"            self._fen_update(pos, 1)",
			"            _list = _lists[pos]",
			"            _list.insert(idx, value)",
			"            _list_lens[pos] += 1",
			"            _mins[pos] = _list[0]",
			"            if _load + _load < len(_list):",
			"                _lists.insert(pos + 1, _list[_load:])",
			"                _list_lens.insert(pos + 1, len(_list) - _load)",
			"                _mins.insert(pos + 1, _list[_load])",
			"                _list_lens[pos] = _load",
			"                del _list[_load:]",
			"                self._rebuild = True",
			"        else:",
			"            _lists.append([value])",
			"            _mins.append(value)",
			"            _list_lens.append(1)",
			"            self._rebuild = True",
			"",
			"    def discard(self, value):",
			"        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"",
			"        _lists = self._lists",
			"        if _lists:",
			"            pos, idx = self._loc_right(value)",
			"            if idx and _lists[pos][idx - 1] == value:",
			"                self._delete(pos, idx - 1)",
			"",
			"    def remove(self, value):",
			"        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"",
			"        _len = self._len",
			"        self.discard(value)",
			"        if _len == self._len:",
			"            raise ValueError('{0!r} not in list'.format(value))",
			"",
			"    def pop(self, index=-1):",
			"        \"\"\"Remove and return value at `index` in sorted list.\"\"\"",
			"        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
			"        value = self._lists[pos][idx]",
			"        self._delete(pos, idx)",
			"        return value",
			"",
			"    def bisect_left(self, value):",
			"        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"",
			"        pos, idx = self._loc_left(value)",
			"        return self._fen_query(pos) + idx",
			"",
			"    def bisect_right(self, value):",
			"        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"",
			"        pos, idx = self._loc_right(value)",
			"        return self._fen_query(pos) + idx",
			"",
			"    def count(self, value):",
			"        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"",
			"        return self.bisect_right(value) - self.bisect_left(value)",
			"",
			"    def __len__(self):",
			"        \"\"\"Return the size of the sorted list.\"\"\"",
			"        return self._len",
			"",
			"    def __getitem__(self, index):",
			"        \"\"\"Lookup value at `index` in sorted list.\"\"\"",
			"        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
			"        return self._lists[pos][idx]",
			"",
			"    def __delitem__(self, index):",
			"        \"\"\"Remove value at `index` from sorted list.\"\"\"",
			"        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
			"        self._delete(pos, idx)",
			"",
			"    def __contains__(self, value):",
			"        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"",
			"        _lists = self._lists",
			"        if _lists:",
			"            pos, idx = self._loc_left(value)",
			"            return idx < len(_lists[pos]) and _lists[pos][idx] == value",
			"        return False",
			"",
			"    def __iter__(self):",
			"        \"\"\"Return an iterator over the sorted list.\"\"\"",
			"        return (value for _list in self._lists for value in _list)",
			"",
			"    def __reversed__(self):",
			"        \"\"\"Return a reverse iterator over the sorted list.\"\"\"",
			"        return (value for _list in reversed(self._lists) for value in reversed(_list))",
			"",
			"    def __repr__(self):",
			"        \"\"\"Return string representation of sorted list.\"\"\"",
			"        return 'SortedList({0})'.format(list(self))"
		],
		"description": "sortedset"
	},
	"python fastio": {
		"prefix": "fastio",
		"body": [
			"import sys",
			"import os",
			"import io",
			"input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline",
			"# input = sys.stdin.readline",
			"# whenever s=input() is used replace it with s=input().strip() for rem \\n",
			""
		],
		"description": "python fastio"
	},
	"Equal sum partition python": {
		"prefix": "equal sum partition",
		"body": [
			"def equal_sum_partition(arr,n):",
			"    sum = 0",
			"    for i in range(n):",
			"        sum += arr[i]",
			"    if sum % 2 != 0:",
			"        return False",
			"",
			"    part = [[True for i in range(n + 1)]",
			"            for j in range(sum // 2 + 1)]",
			"",
			"    for i in range(0, n + 1):",
			"        part[0][i] = True",
			"",
			"    for i in range(1, sum // 2 + 1):",
			"        part[i][0] = False",
			"",
			"    for i in range(1, sum // 2 + 1):",
			"",
			"        for j in range(1, n + 1):",
			"            part[i][j] = part[i][j - 1]",
			"",
			"            if i >= arr[j - 1]:",
			"                part[i][j] = (part[i][j] or",
			"                              part[i - arr[j - 1]][j - 1])",
			"",
			"    return part[sum // 2][n]",
			"",
			"def bin_sum_array(arr,n):",
			"    for i in range(n):",
			"        if arr[i]%2==1:",
			"            return i+1",
			"    binarray=[list(reversed(bin(i)[2:])) for i in arr]",
			"    new_array=[0 for i in range(32)]",
			"    for i in binarray:",
			"        for j in range(len(i)):",
			"            if i[j]=='1':",
			"                new_array[j]+=1",
			"    return new_array"
		],
		"description": "Equal sum partition python"
	},
	"dijkstra algorithm": {
		"prefix": "dijkshtra with parent",
		"body": [
			"from heapq import heappop, heappush",
			"",
			"",
			"def dijkstra(graph, start):",
			"    \"\"\"",
			"        Uses Dijkstra's algortihm to find the shortest path from node start",
			"        to all other nodes in a directed weighted graph.",
			"    \"\"\"",
			"    \"\"\"",
			"        graph is like graph[0] contains [edge,weight] pairs",
			"        graph[0]=[[1,wt=100],[2,wt=2]]",
			"",
			"    \"\"\"",
			"    n = len(graph)",
			"    dist, parents = [float(\"inf\")] * n, [-1] * n",
			"    dist[start] = 0",
			"",
			"    queue = [(0, start)]",
			"    while queue:",
			"        path_len, v = heappop(queue)",
			"        if path_len == dist[v]:",
			"            for w, edge_len in graph[v]:",
			"                if edge_len + path_len < dist[w]:",
			"                    dist[w], parents[w] = edge_len + path_len, v",
			"                    heappush(queue, (edge_len + path_len, w))",
			"",
			"    return dist, parents",
			"",
			"",
			"# graph = [[[1, 100], [2, 500]], [[2, 100]], []]",
			"# src = 0",
			"# ans = dijkstra(graph, src)",
			"# print(ans)"
		],
		"description": "dijkstra algorithm"
	},
	"disjoint set union defaultdict": {
		"prefix": "disjoint set union defaultdict",
		"body": [
			"class DisjointSetUnion:",
			"    def __init__(self,l=[]):",
			"        self.parent = defaultdict(int)",
			"        self.size = defaultdict(lambda :1)",
			"        self.num_sets = 0",
			"        for i in l:",
			"            self.add(i)",
			"    def add(self,val):",
			"        if val not in self.parent:",
			"            self.parent[val]=val",
			"            self.size[val]=1",
			"            self.num_sets+=1",
			"    def find(self, a):",
			"        acopy = a",
			"        while a != self.parent[a]:",
			"            a = self.parent[a]",
			"        while acopy != a:",
			"            self.parent[acopy], acopy = a, self.parent[acopy]",
			"        return a",
			"",
			"    def union(self, a, b):",
			"        a, b = self.find(a), self.find(b)",
			"        if a != b:",
			"            if self.size[a] < self.size[b]:",
			"                a, b = b, a",
			"",
			"            self.num_sets -= 1",
			"            self.parent[b] = a",
			"            self.size[a] += self.size[b]",
			"            return 1",
			"        return 0",
			"",
			"    def set_size(self, a):",
			"        return self.size[self.find(a)]",
			"",
			"    def __len__(self):",
			"        return self.num_sets"
		],
		"description": "disjoint set union defaultdict"
	},
	"cpp plag remove": {
		"prefix": "cpp plag",
		"body": [
			"file = open('cf.cpp', 'r')",
			"out = open('cf2.cpp', 'w')",
			"",
			"",
			"class string_generator:",
			"    def __init__(self):",
			"        self.count = 0",
			"        self.stringname = \"int randomvar\"",
			"        self.stringvalue = \"=0;\"",
			"        self.curly_brackets = 0",
			"",
			"    def get_string(self):",
			"        self.count += 1",
			"        return self.stringname+str(self.count)+self.stringvalue",
			"",
			"    def get_stringln(self):",
			"        return self.get_string()+\"\\n\"",
			"",
			"    def update_curly_bracket(self, s):",
			"        self.curly_brackets += s.count(\"{\")-s.count(\"}\")",
			"",
			"    def get_curly_bracket(self):",
			"        return self.curly_brackets",
			"",
			"",
			"var = string_generator()",
			"for i in file:",
			"    if i[-1] == '\\n':",
			"        i = i[:-1]",
			"    var.update_curly_bracket(i)",
			"    spacecount = 0",
			"    for counter in i:",
			"        if counter == \" \":",
			"            spacecount += 1",
			"        else:",
			"            break",
			"    i = i[spacecount:]",
			"    out.write(\" \"*spacecount)",
			"    if i.startswith(\"#\"):",
			"        out.write(var.get_stringln())",
			"    if i.startswith(\"for\"):",
			"        if var.get_curly_bracket():",
			"            out.write(var.get_stringln())",
			"        else:",
			"            out.write(var.get_string())",
			"    if i.startswith(\"while\"):",
			"        out.write(var.get_string())",
			"    if i.startswith(\"if\"):",
			"        out.write(var.get_string())",
			"",
			"    out.write(i)",
			"    try:",
			"        if len(i) == 0:",
			"            out.write(var.get_string())",
			"        elif i.endswith(';'):",
			"",
			"            out.write(var.get_string())",
			"            out.write(var.get_string())",
			"    except Exception as ex:",
			"        print(ex)",
			"    out.write('\\n')",
			""
		],
		"description": "cpp plag remove"
	},
	"count primes": {
		"prefix": "sieve for large number",
		"body": [
			"a9=int((10**4.5))+100",
			"prime = [True for i in range(a9 + 1)]",
			"def SieveOfEratosthenes(n):",
			"    p = 2",
			"    while (p * p <= n):",
			"        if (prime[p] == True):",
			"            for i in range(p * p, n + 1, p):",
			"                prime[i] = False",
			"        p += 1",
			"SieveOfEratosthenes(a9)",
			"prime_number=[]",
			"for i in range(2,a9):",
			"    if prime[i]:",
			"        prime_number.append(i)",
			"",
			"def countprimes(a):",
			"    count=0",
			"    for i in prime_number:",
			"        while a%i==0:",
			"            count+=1",
			"            a//=i;",
			"    if a>2:",
			"        count+=1",
			"    return count",
			""
		],
		"description": "count primes"
	},
	"python plag remove": {
		"prefix": "python plag remove",
		"body": [
			"file = open('cf.py', 'r')",
			"out = open('cf2.py', 'w')",
			"string = \"ali=0\"",
			"for i in file:",
			"    if i and i[-1]=='\\n':",
			"        i = i[:-1]",
			"",
			"    if i and i[-1] == \";\":",
			"        i = i[:-1]",
			"",
			"    counter = 0",
			"    for j in i:",
			"",
			"        if j == ' ':",
			"            counter += 1",
			"        else:",
			"            break",
			"    i = i[counter:]",
			"    try:",
			"        if len(i) == 0:",
			"            out.write(\" \"*counter)",
			"            out.write(i)",
			"        elif i.endswith(','):",
			"            out.write(\" \"*counter)",
			"            out.write(i)",
			"        elif i.endswith(':'):",
			"            if i.startswith('if'):",
			"                out.write(\" \"*counter+string+\";\\n\")",
			"            out.write(\" \"*counter)",
			"            out.write(i)",
			"        elif i.startswith('def'):",
			"            out.write(\" \"*counter)",
			"            out.write(i)",
			"            out.write(';'+string)",
			"            out.write(\"\\n\"+\" \"*counter+string+\";\")",
			"        else:",
			"            out.write(\" \"*counter+string+\";\")",
			"            out.write(i)",
			"            out.write(';'+string)",
			"            out.write(\"\\n\"+\" \"*counter+string+\";\")",
			"    except:",
			"        out.write(\" \"*counter)",
			"        out.write(i)",
			"    out.write('\\n')",
			""
		],
		"description": "python plag remove"
	},
	"Trie made by me": {
		"prefix": "Trie made by me",
		"body": [
			"class Trie:",
			"    def __init__(self, *words):",
			"        self.root = dict()",
			"        for word in words:",
			"            self.add(word)",
			"        self.searching_method=[self.dfs,self.dfs_iterative,self.bfs]",
			"    def add(self, word):",
			"        current_dict = self.root",
			"        for letter in word:",
			"            current_dict = current_dict.setdefault(letter, dict())",
			"        current_dict[\"_end_\"] = True",
			"",
			"    def __contains__(self, word):",
			"        current_dict = self.root",
			"        for letter in word:",
			"            if letter not in current_dict:",
			"                return False",
			"            current_dict = current_dict[letter]",
			"        return \"_end_\" in current_dict",
			"",
			"    def __delitem__(self, word):",
			"        current_dict = self.root",
			"        nodes = [current_dict]",
			"        for letter in word:",
			"            current_dict = current_dict[letter]",
			"            nodes.append(current_dict)",
			"        del current_dict[\"_end_\"]",
			"        nodes.pop()",
			"        for letter in reversed(word):",
			"            if nodes[-1][letter]=={}:",
			"                del nodes[-1][letter]",
			"            nodes.pop()",
			"    def prefix(self,word,search_index=2):",
			"        \"\"\"print all the possible words starting with preifx word(parameter of prefix)\"\"\"",
			"        current_dict = self.root",
			"        for letter in word:",
			"            if letter not in current_dict:",
			"                return \"\"",
			"            current_dict = current_dict[letter]",
			"        return self.searching_method[search_index](current_dict,word)",
			"    def dfs(self,current_dict,prefix_word):",
			"        \"\"\"dfs to print words through prefix_word\"\"\"",
			"        for j in current_dict:",
			"            if j=='_end_':",
			"                print(prefix_word)",
			"            else:",
			"                self.dfs(current_dict[j],prefix_word+j)",
			"    def dfs_iterative(self,current_dict,prefix_word):",
			"        \"\"\"dfs to print words through prefix_word\"\"\"",
			"        stack=[]",
			"        words_queue = [prefix_word]",
			"        stack.append(current_dict)",
			"        while stack:",
			"            current_dict=stack.pop()",
			"            prefix_word=words_queue.pop()",
			"            for j in current_dict:",
			"                if j=='_end_':",
			"                    print(prefix_word)",
			"                else:",
			"                    stack.append(current_dict[j])",
			"                    words_queue.append(prefix_word+j)",
			"",
			"",
			"    def bfs(self,current_dict,prefix_word):",
			"        \"\"\"bfs to print words through prefix_word\"\"\"",
			"        q=deque()",
			"        words_queue = deque()",
			"        q.append(current_dict)",
			"        words_queue.append(prefix_word)",
			"        ans=[]",
			"        while len(q):",
			"            current_dict=q.popleft()",
			"            prefix_word=words_queue.popleft()",
			"            for j in current_dict:",
			"                if j=='_end_':",
			"                    ans.append(prefix_word)",
			"                else:",
			"                    q.append(current_dict[j])",
			"                    words_queue.append(prefix_word+j)",
			"        return ans",
			"    def count_prefix(self,word):",
			"        current_dict = self.root",
			"        for letter in word:",
			"            if letter not in current_dict:",
			"                return 0",
			"            current_dict = current_dict[letter]",
			"        return self.bfs_count(current_dict, word)",
			"    def bfs_count(self,current_dict,prefix_word):",
			"        \"\"\"bfs to count all words starting through prefix_word\"\"\"",
			"        q=deque()",
			"        q.append(current_dict)",
			"        counter=0",
			"        while len(q):",
			"            current_dict=q.popleft()",
			"            for j in current_dict:",
			"                if j=='_end_':",
			"                    counter+=1",
			"                else:",
			"                    q.append(current_dict[j])",
			"        return counter",
			"    def regex_search(self,word):",
			"        \"\"\"searches if word is present in trie word may contain regex .\"\"\"",
			"        current_dict=self.root",
			"        return self.dfs_search(current_dict,word,0)",
			"    def dfs_search(self,current_dict,word,indexa):",
			"        if type(current_dict)==bool:",
			"            return 0",
			"        if indexa==len(word):",
			"            return \"_end_\" in current_dict",
			"        if word[indexa]=='.':",
			"            for i in current_dict:",
			"                if self.dfs_search(current_dict[i],word,indexa+1):",
			"                    return 1",
			"            return 0",
			"        else:",
			"            if word[indexa] in current_dict:",
			"                return self.dfs_search(current_dict[word[indexa]],word,indexa+1)",
			"    def max_xor(self,a,bits=32):",
			"        current_dict=self.root",
			"        ans=[]",
			"        for indexa in range(bits):",
			"            if a[indexa] == '0':",
			"                current_bit = '1'",
			"            else:",
			"                current_bit = '0'",
			"            if current_bit in current_dict:",
			"                current_dict=current_dict[current_bit]",
			"                ans.append(current_bit)",
			"            else:",
			"                current_dict=current_dict[a[indexa]]",
			"                ans.append(a[indexa])",
			"        return ''.join(ans)",
			"    def bit_binary(self,a):",
			"        return '{:032b}'.format(a)",
			"    def get_max_xor_array(self,arr):",
			"        arrbits = [self.bit_binary(i) for i in arr]",
			"        n = len(arr)",
			"        for i in arrbits:",
			"            self.add(i)",
			"        maxans = 0",
			"        for i in range(n):",
			"            string = self.max_xor(arrbits[i])",
			"            num = int(string, 2)",
			"            maxans = max(maxans, num ^ arr[i])",
			"        return maxans"
		],
		"description": "Trie made by me"
	},
	"RabinKarpAdv": {
		"prefix": "RabinKarpAdv",
		"body": [
			"\"\"\"",
			"Warnings:",
			"s is a list of integers (for str convert it to ascii and then call)",
			"For this hash only one of the things can be used at a time",
			"only pushbackes,popbacks, and current_back_hash",
			"or ",
			"only pushfrontes,popfronts and current_front_outputs",
			"or ",
			"only rollback and current_back_hash",
			"or ",
			"only roll_front and current_front_hash",
			"popback and popfront do not update the hashlist only updates pointers",
			"\"\"\"",
			"class RabinKarpAdv:",
			"    def __init__(self,s,k,start=0,all=0,p=10**9+7,d=26):",
			"        \"\"\"s is a list of integers \"\"\"",
			"        hash=0",
			"        self.d=d",
			"        self.p=p",
			"        self.s=s",
			"        self.firstpointer=start",
			"        self.lastpointer=start+k",
			"        self.pow=pow(d,k-1,p)",
			"        self.hashlist=defaultdict(int)",
			"        for i in range(start,start+k):",
			"            hash=(hash*d+s[i])%p",
			"            self.hashlist[i]=hash",
			"        if all:",
			"            self.firstpointer=len(s)-k",
			"            self.lastpointer=len(s)",
			"            for i in range(start+k,len(s)):",
			"                hash=(d*(hash-s[i-k]*self.pow)+s[i])%p",
			"                self.hashlist[i]=hash",
			"    def roll_back(self):",
			"        self.hashlist[self.lastpointer]=(self.d*(self.hashlist[self.lastpointer-1]-self.s[self.firstpointer]*self.pow)+self.s[self.lastpointer])%self.p",
			"        self.firstpointer+=1",
			"        self.lastpointer+=1",
			"",
			"",
			"    def push_back(self):",
			"        self.hashlist[self.lastpointer]=(self.d*self.hashlist[self.lastpointer-1]+self.s[self.lastpointer])%self.p",
			"        self.lastpointer+=1",
			"    def pop_back(self):",
			"        self.lastpointer-=1",
			"    def current_back_hash(self):",
			"        return self.hashlist[self.lastpointer-1]",
			"    def push_front(self):",
			"        \"\"\"order log n update\"\"\"",
			"        self.len=self.lastpointer-self.firstpointer",
			"        self.pow=pow(self.d,self.len,self.p)",
			"        self.hashlist[self.firstpointer-1]=(self.s[self.firstpointer-1]*self.pow+self.hashlist[self.firstpointer])%self.p",
			"        self.firstpointer-=1",
			"    def pop_front(self):",
			"        self.len = self.lastpointer - self.firstpointer",
			"        self.pow=pow(self.d,self.len,self.p)",
			"        self.firstpointer+=1",
			"    def current_front_hash(self):",
			"        return self.hashlist[self.firstpointer]",
			"    def query(self,start,k):",
			"        \"\"\" query fron start=0 to start=n-k\"\"\"",
			"        return self.hashlist[start+k-1]",
			"    def samestring(self,s,i,j,k):",
			"        for counter in range(k):",
			"            if s[i+counter]!=s[j+counter]:",
			"                return 0",
			"        return 1"
		],
		"description": "RabinKarpAdv"
	},
	"RabinKarpFront": {
		"prefix": "RabinKarpFront",
		"body": [
			"class RabinKarpFront:",
			"    def __init__(self,s,k,start=-1,all=0,p=10**9+7,d=26):",
			"        \"\"\"s is a list of integers \"\"\"",
			"        if(start==-1):",
			"            start=len(s)",
			"",
			"        hash=0",
			"        self.d=d",
			"        self.p=p",
			"        self.s=s",
			"        self.firstpointer=start-k",
			"        self.lastpointer=start",
			"        self.pow=pow(d,k-1,p)",
			"        self.hashlist=defaultdict(int)",
			"        for i in range(start-1,start-k-1,-1):",
			"            hash=(hash*d+s[i])%p",
			"            self.hashlist[i]=hash",
			"        if all:",
			"            self.firstpointer=len(s)-k",
			"            self.lastpointer=len(s)",
			"            for i in range(start-k-1,-1,-1):",
			"                hash=(d*(hash-s[i+k]*self.pow)+s[i])%p",
			"                self.hashlist[i]=hash",
			"    def push_front(self):",
			"        self.hashlist[self.firstpointer-1]=(self.s[self.firstpointer-1]+self.d*self.hashlist[self.firstpointer])%self.p",
			"        self.firstpointer-=1",
			"    def pop_front(self):",
			"        self.len = self.lastpointer - self.firstpointer",
			"        self.pow=pow(self.d,self.len,self.p)",
			"        self.firstpointer+=1",
			"    def roll_front(self):",
			"        self.hashlist[self.firstpointer - 1] = (self.s[self.firstpointer - 1] + self.d * (self.hashlist[self.firstpointer]-self.s[self.lastpointer-1]*self.pow)) % self.p",
			"        self.firstpointer-=1",
			"        self.lastpointer-=1",
			"    def roll_back(self):",
			"        self.hashlist[self.firstpointer+1]=self.hashlist[self.firstpointer]-self.s[self.firstpointer]",
			"        while self.hashlist[self.firstpointer+1]%self.d!=0:",
			"            self.hashlist[self.firstpointer+1]+=self.p",
			"        self.hashlist[self.firstpointer+1]//=self.d",
			"        self.hashlist[self.firstpointer+1]=(self.hashlist[self.firstpointer+1]+self.pow*self.s[self.lastpointer])%self.p",
			"        self.firstpointer+=1",
			"        self.lastpointer+=1",
			"        return self.hashlist[self.firstpointer]",
			"    def current_front_hash(self):",
			"        return self.hashlist[self.firstpointer]",
			"",
			"    def samestring(self,s,i,j,k):",
			"        for counter in range(k):",
			"            if s[i+counter]!=s[j+counter]:",
			"                return 0",
			"        return 1"
		],
		"description": "RabinKarpFront"
	},
	"32 bit binary": {
		"prefix": "32 bit binary",
		"body": [
			"def bit_binary(a):",
			"    return '{:032b}'.format(a)"
		],
		"description": "32 bit binary"
	},
	"fast sieve": {
		"prefix": "fast sieve",
		"body": [
			"def prime_sieve(n):",
			"    \"\"\"returns a sieve of primes >= 5 and < n\"\"\"",
			"    flag = n % 6 == 2",
			"    sieve = bytearray((n // 3 + flag >> 3) + 1)",
			"    for i in range(1, int(n**0.5) // 3 + 1):",
			"        if not (sieve[i >> 3] >> (i & 7)) & 1:",
			"            k = (3 * i + 1) | 1",
			"            for j in range(k * k // 3, n // 3 + flag, 2 * k):",
			"                sieve[j >> 3] |= 1 << (j & 7)",
			"            for j in range(k * (k - 2 * (i & 1) + 4) // 3, n // 3 + flag, 2 * k):",
			"                sieve[j >> 3] |= 1 << (j & 7)",
			"    return sieve",
			"",
			"",
			"def prime_list(n):",
			"    \"\"\"returns a list of primes <= n\"\"\"",
			"    res = []",
			"    if n > 1:",
			"        res.append(2)",
			"    if n > 2:",
			"        res.append(3)",
			"    if n > 4:",
			"        sieve = prime_sieve(n + 1)",
			"        res.extend(3 * i + 1 | 1 for i in range(1, (n + 1) // 3 +",
			"                                                (n % 6 == 1)) if not (sieve[i >> 3] >> (i & 7)) & 1)",
			"    return res",
			""
		],
		"description": "fast sieve"
	},
	"spf": {
		"prefix": "spf",
		"body": [
			"import math as mt",
			"MAXN=10**7",
			"spf = [0 for i in range(MAXN)]",
			"def sieve():",
			"    spf[1] = 1",
			"    for i in range(2, MAXN):",
			"        # marking smallest prime factor",
			"        # for every number to be itself.",
			"        spf[i] = i",
			"",
			"        # separately marking spf for",
			"    # every even number as 2",
			"    for i in range(4, MAXN, 2):",
			"        spf[i] = 2",
			"",
			"    for i in range(3, mt.ceil(mt.sqrt(MAXN))):",
			"",
			"        # checking if i is prime",
			"        if (spf[i] == i):",
			"",
			"            # marking SPF for all numbers",
			"            # divisible by i",
			"            for j in range(i * i, MAXN, i):",
			"",
			"                # marking spf[j] if it is",
			"                # not previously marked",
			"                if (spf[j] == j):",
			"                    spf[j] = i",
			"def getFactorization(x):",
			"    ret = list()",
			"    while (x != 1):",
			"        ret.append(spf[x])",
			"        x = x // spf[x]",
			"",
			"    return ret",
			"sieve()"
		],
		"description": "spf"
	},
	"sieve": {
		"prefix": "sieve",
		"body": [
			"a9=pow(10,5)+100",
			"prime = [True for i in range(a9 + 1)]",
			"def SieveOfEratosthenes(n):",
			"    p = 2",
			"    while (p * p <= n):",
			"        if (prime[p] == True):",
			"            for i in range(p * p, n + 1, p):",
			"                prime[i] = False",
			"        p += 1",
			"SieveOfEratosthenes(a9)",
			"prime_number=[]",
			"for i in range(2,a9):",
			"    if prime[i]:",
			"        prime_number.append(i)"
		],
		"description": "sieve"
	}
}
