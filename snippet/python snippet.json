{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"python boilerplate": {
		"prefix": "boilerplate",
		"body": [
			"from itertools import combinations, permutations, combinations_with_replacement, product",
			"",
			"import itertools",
			"from timeit import timeit",
			"import timeit",
			"import time",
			"from time import time",
			"from random import *",
			"import random",
			"import collections",
			"import bisect",
			"import os",
			"import math",
			"from collections import defaultdict, OrderedDict, Counter",
			"from sys import stdin, stdout",
			"from bisect import bisect_left, bisect_right",
			"# import numpy as np",
			"from queue import Queue, PriorityQueue",
			"from heapq import *",
			"from statistics import *",
			"from math import sqrt, log10, log2, log, gcd, ceil, floor",
			"import fractions",
			"import copy",
			"from copy import deepcopy",
			"import sys",
			"import io",
			"import string",
			"from string import ascii_lowercase,ascii_uppercase,ascii_letters,digits",
			"sys.setrecursionlimit(10000)",
			"",
			"mod = int(pow(10, 9)) + 7",
			"",
			"",
			"def ncr(n, r, p=mod):",
			"    num = den = 1",
			"    for i in range(r):",
			"        num = (num * (n - i)) % p",
			"        den = (den * (i + 1)) % p",
			"    return (num * pow(den,",
			"                      p - 2, p)) % p",
			"",
			"",
			"def normalncr(n, r):",
			"    r = min(r, n - r)",
			"    count = 1",
			"    for i in range(n - r, n + 1):",
			"        count *= i",
			"",
			"    for i in range(1, r + 1):",
			"        count //= i",
			"    return count",
			"",
			"",
			"inf = float(\"inf\")",
			"adj = defaultdict(set)",
			"visited = defaultdict(int)",
			"",
			"",
			"def addedge(a, b):",
			"    adj[a].add(b)",
			"    adj[b].add(a)",
			"",
			"",
			"def bfs(v):",
			"    q = Queue()",
			"    q.put(v)",
			"    visited[v] = 1",
			"    while q.qsize() > 0:",
			"        s = q.get_nowait()",
			"        print(s)",
			"        for i in adj[s]:",
			"            if visited[i] == 0:",
			"                q.put(i)",
			"                visited[i] = 1",
			"",
			"",
			"def dfs(v, visited):",
			"    if visited[v] == 1:",
			"        return",
			"    visited[v] = 1",
			"",
			"    print(v)",
			"    for i in adj[v]:",
			"        dfs(i, visited)",
			"",
			"",
			"# a9=pow(10,5)+100",
			"# prime = [True for i in range(a9 + 1)]",
			"# def SieveOfEratosthenes(n):",
			"#     p = 2",
			"#     while (p * p <= n):",
			"#         if (prime[p] == True):",
			"#             for i in range(p * p, n + 1, p):",
			"#                 prime[i] = False",
			"#         p += 1",
			"# SieveOfEratosthenes(a9)",
			"# prime_number=[]",
			"# for i in range(2,a9):",
			"#     if prime[i]:",
			"#         prime_number.append(i)",
			"",
			"",
			"def reverse_bisect_right(a, x, lo=0, hi=None):",
			"    if lo < 0:",
			"        raise ValueError('lo must be non-negative')",
			"    if hi is None:",
			"        hi = len(a)",
			"    while lo < hi:",
			"        mid = (lo + hi) // 2",
			"        if x > a[mid]:",
			"            hi = mid",
			"        else:",
			"            lo = mid + 1",
			"    return lo",
			"",
			"",
			"def reverse_bisect_left(a, x, lo=0, hi=None):",
			"    if lo < 0:",
			"        raise ValueError('lo must be non-negative')",
			"    if hi is None:",
			"        hi = len(a)",
			"    while lo < hi:",
			"        mid = (lo + hi) // 2",
			"        if x >= a[mid]:",
			"            hi = mid",
			"        else:",
			"            lo = mid + 1",
			"    return lo",
			"",
			"",
			"def get_list():",
			"    return list(map(int, input().split()))",
			"",
			"",
			"def make_list(m):",
			"    m += list(map(int, input().split()))",
			"",
			"",
			"def get_str_list_in_int():",
			"    return [int(i) for i in list(input())]",
			"",
			"",
			"def get_str_list():",
			"    return list(input())",
			"",
			"",
			"def get_map():",
			"    return map(int, input().split())",
			"",
			"",
			"def input_int():",
			"    return int(input())",
			"",
			"",
			"def matrix(a, b):",
			"    return [[0 for i in range(b)] for j in range(a)]",
			"",
			"",
			"def swap(a, b):",
			"    return b, a",
			"",
			"",
			"def find_gcd(l):",
			"    a = l[0]",
			"    for i in range(len(l)):",
			"        a = gcd(a, l[i])",
			"    return a",
			"",
			"",
			"def is_prime(n):",
			"    sqrta = int(sqrt(n))",
			"    for i in range(2, sqrta + 1):",
			"        if n % i == 0:",
			"            return 0",
			"    return 1",
			"",
			"",
			"def prime_factors(n):",
			"    l = []",
			"    while n % 2 == 0:",
			"        l.append(2)",
			"        n //= 2",
			"    sqrta = int(sqrt(n))",
			"",
			"    for i in range(3, sqrta + 1, 2):",
			"        while n % i == 0:",
			"            n //= i",
			"            l.append(i)",
			"    if n > 2:",
			"        l.append(n)",
			"    return l",
			"",
			"",
			"def p(a):",
			"    if type(a) == str:",
			"        print(a + \"\\n\")",
			"    else:",
			"        print(str(a) + \"\\n\")",
			"",
			"",
			"def ps(a):",
			"    if type(a) == str:",
			"        print(a)",
			"    else:",
			"        print(str(a))",
			"",
			"",
			"def kth_no_not_div_by_n(n, k):",
			"    return k + (k - 1) // (n - 1)",
			"",
			"",
			"def forward_array(l):",
			"    \"\"\"",
			"    returns the forward index where the elemetn is just greater than that element",
			"    [100,200] gives [1,2]",
			"    because element at index 1 is greater than 100 and nearest",
			"    similarly if it is largest then it outputs n",
			"    :param l:",
			"    :return:",
			"    \"\"\"",
			"    n = len(l)",
			"    stack = []",
			"    forward = [0] * n",
			"    for i in range(len(l) - 1, -1, -1):",
			"        while len(stack) and l[stack[-1]] < l[i]:",
			"            stack.pop()",
			"        if len(stack) == 0:",
			"            forward[i] = len(l)",
			"        else:",
			"            forward[i] = stack[-1]",
			"        stack.append(i)",
			"    return forward",
			"",
			"",
			"def forward_array_notequal(l):",
			"    n = len(l)",
			"    stack = []",
			"    forward = [n]*n",
			"    for i in range(len(l) - 1, -1, -1):",
			"        while len(stack) and l[stack[-1]] <= l[i]:",
			"            stack.pop()",
			"        if len(stack) == 0:",
			"            forward[i] = len(l)",
			"        else:",
			"            forward[i] = stack[-1]",
			"        stack.append(i)",
			"    return forward",
			"",
			"",
			"def backward_array(l):",
			"    n = len(l)",
			"    stack = []",
			"    backward = [0] * n",
			"    for i in range(len(l)):",
			"        while len(stack) and l[stack[-1]] < l[i]:",
			"            stack.pop()",
			"        if len(stack) == 0:",
			"            backward[i] = -1",
			"        else:",
			"            backward[i] = stack[-1]",
			"        stack.append(i)",
			"    return backward",
			"",
			"",
			"def char(a):",
			"    return chr(a + 97)",
			"",
			"",
			"def get_length(a):",
			"    return 1 + int(log10(a))",
			"",
			"",
			"def issq(n):",
			"    sqrta = int(n ** 0.5)",
			"    return sqrta ** 2 == n",
			"",
			"",
			"def ceil(a, b):",
			"    return int((a+b-1)/b)",
			"",
			"",
			"def equal_sum_partition(arr, n):",
			"    sum = 0",
			"    for i in range(n):",
			"        sum += arr[i]",
			"    if sum % 2 != 0:",
			"        return False",
			"",
			"    part = [[True for i in range(n + 1)]",
			"            for j in range(sum // 2 + 1)]",
			"",
			"    for i in range(0, n + 1):",
			"        part[0][i] = True",
			"",
			"    for i in range(1, sum // 2 + 1):",
			"        part[i][0] = False",
			"",
			"    for i in range(1, sum // 2 + 1):",
			"",
			"        for j in range(1, n + 1):",
			"            part[i][j] = part[i][j - 1]",
			"",
			"            if i >= arr[j - 1]:",
			"                part[i][j] = (part[i][j] or",
			"                              part[i - arr[j - 1]][j - 1])",
			"",
			"    return part[sum // 2][n]",
			"",
			"",
			"def bin_sum_array(arr, n):",
			"    for i in range(n):",
			"        if arr[i] % 2 == 1:",
			"            return i+1",
			"    binarray = [list(reversed(bin(i)[2:])) for i in arr]",
			"    new_array = [0 for i in range(32)]",
			"    for i in binarray:",
			"        for j in range(len(i)):",
			"            if i[j] == '1':",
			"                new_array[j] += 1",
			"    return new_array",
			"",
			"",
			"def ispalindrome(s):",
			"    return s == s[::-1]",
			"",
			"",
			"def get_prefix(l):",
			"    if l == []:",
			"        return []",
			"    prefix = [l[0]]",
			"    for i in range(1, len(l)):",
			"        prefix.append(prefix[-1]+l[i])",
			"    return prefix",
			"",
			"",
			"def get_suffix(l):",
			"    if l == []:",
			"        return []",
			"    suffix = [l[-1]]*len(l)",
			"    for i in range(len(l)-2, -1, -1):",
			"        suffix[i] = suffix[i+1]+l[i]",
			"    return suffix",
			"",
			"",
			"nc = \"NO\"",
			"yc = \"YES\"",
			"ns = \"No\"",
			"ys = \"Yes\"",
			"",
			"",
			"def yesno(a):",
			"    print(yc if a else nc)",
			"",
			"",
			"def reduce(dict, a):",
			"    dict[a] -= 1",
			"    if dict[a] == 0:",
			"        dict.pop(a)",
			"",
			"",
			"",
			"# import math as mt",
			"# MAXN=10**7",
			"# spf = [0 for i in range(MAXN)]",
			"# def sieve():",
			"#     spf[1] = 1",
			"#     for i in range(2, MAXN):",
			"#         # marking smallest prime factor",
			"#         # for every number to be itself.",
			"#         spf[i] = i",
			"#",
			"#         # separately marking spf for",
			"#     # every even number as 2",
			"#     for i in range(4, MAXN, 2):",
			"#         spf[i] = 2",
			"#",
			"#     for i in range(3, mt.ceil(mt.sqrt(MAXN))):",
			"#",
			"#         # checking if i is prime",
			"#         if (spf[i] == i):",
			"#",
			"#             # marking SPF for all numbers",
			"#             # divisible by i",
			"#             for j in range(i * i, MAXN, i):",
			"#",
			"#                 # marking spf[j] if it is",
			"#                 # not previously marked",
			"#                 if (spf[j] == j):",
			"#                     spf[j] = i",
			"# def getFactorization(x):",
			"#     ret = list()",
			"#     while (x != 1):",
			"#         ret.append(spf[x])",
			"#         x = x // spf[x]",
			"#",
			"#     return ret",
			"# sieve()",
			"",
			"",
			"# if(os.path.exists('input.txt')):",
			"#     sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\")",
			"",
			"import sys",
			"import io",
			"from sys import stdin, stdout",
			"# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline",
			"input=sys.stdin.readline",
			"# print=sys.stdout.write",
			"t = 1",
			"",
			"t=int(input())",
			"for i in range(t):",
			"    n,k=get_list()",
			"    l=get_list()",
			"",
			"",
			"",
			"",
			""
		],
		"description": "python boilerplate"
	},
	"python small boilerplate": {
		"prefix": "small boilerplate",
		"body": [
			"from collections import defaultdict,Counter",
			"from math import sqrt, log10, log2, log, gcd, ceil, floor",
			"from bisect import bisect_left, bisect_right",
			"from itertools import permutations",
			"import sys,io,os;",
			"input=sys.stdin.readline",
			"# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline",
			"# print=sys.stdout.write",
			"sys.setrecursionlimit(10000)",
			"mod=int(pow(10,7)+9)",
			"inf = float('inf')",
			"def get_list():",
			"    return [int(i) for i in input().split()]",
			"def yn(a):",
			"    print(\"YES\" if a else \"NO\")",
			"t = 1",
			"",
			"for i in range(int(input())):",
			"    n=int(input())",
			"",
			""
		],
		"description": "python small boilerplate"
	},
	"python fastio": {
		"prefix": "fastio",
		"body": [
			"import sys",
			"import os",
			"import io",
			"input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline",
			"# input = sys.stdin.readline",
			"# whenever s=input() is used replace it with s=input().strip() for rem \\n",
			""
		],
		"description": "python fastio"
	},
	"Equal sum partition python": {
		"prefix": "equal sum partition",
		"body": [
			"def equal_sum_partition(arr,n):",
			"    sum = 0",
			"    for i in range(n):",
			"        sum += arr[i]",
			"    if sum % 2 != 0:",
			"        return False",
			"",
			"    part = [[True for i in range(n + 1)]",
			"            for j in range(sum // 2 + 1)]",
			"",
			"    for i in range(0, n + 1):",
			"        part[0][i] = True",
			"",
			"    for i in range(1, sum // 2 + 1):",
			"        part[i][0] = False",
			"",
			"    for i in range(1, sum // 2 + 1):",
			"",
			"        for j in range(1, n + 1):",
			"            part[i][j] = part[i][j - 1]",
			"",
			"            if i >= arr[j - 1]:",
			"                part[i][j] = (part[i][j] or",
			"                              part[i - arr[j - 1]][j - 1])",
			"",
			"    return part[sum // 2][n]",
			"",
			"def bin_sum_array(arr,n):",
			"    for i in range(n):",
			"        if arr[i]%2==1:",
			"            return i+1",
			"    binarray=[list(reversed(bin(i)[2:])) for i in arr]",
			"    new_array=[0 for i in range(32)]",
			"    for i in binarray:",
			"        for j in range(len(i)):",
			"            if i[j]=='1':",
			"                new_array[j]+=1",
			"    return new_array"
		],
		"description": "Equal sum partition python"
	},
	"cpp plag remove": {
		"prefix": "cpp plag check",
		"body": [
			"file = open('cf.cpp', 'r')",
			"out = open('cf_new.cpp', 'w')",
			"string = \"int ali=0;\"",
			"new_string = \"ali =0;\"",
			"count = 0",
			"for i in file:",
			"    if i[-1] == '\\n':",
			"        i = i[:-1]",
			"",
			"    out.write(i)",
			"    try:",
			"        if len(i) == 0:",
			"            pass",
			"        elif not i.startswith(\" \"):",
			"            pass",
			"        elif not i.startswith(\"\\t\"):",
			"            pass",
			"        elif i.endswith(';'):",
			"            if count == 0:",
			"                out.write(string)",
			"                count += 1",
			"            else:",
			"                out.write(new_string)",
			"    except:",
			"        pass",
			"    out.write('\\n')",
			""
		],
		"description": "cpp plag remove"
	},
	"plag remove ": {
		"prefix": "python plag",
		"body": [
			"file = open('cf.py', 'r')",
			"out = open('cf2.py', 'w')",
			"string = \"ali=0\"",
			"for i in file:",
			"    i = i[:-1]",
			"    counter = 0",
			"    for j in i:",
			"",
			"        if j == ' ':",
			"            counter += 1",
			"        else:",
			"            break",
			"    i = i[counter:]",
			"    try:",
			"        if len(i) == 0:",
			"            out.write(\" \"*counter)",
			"            out.write(i)",
			"        elif i.endswith(','):",
			"            out.write(\" \"*counter)",
			"            out.write(i)",
			"        elif i.endswith(':'):",
			"            if i.startswith('if'):",
			"                out.write(\" \"*counter+string+\";\\n\")",
			"            out.write(\" \"*counter)",
			"            out.write(i)",
			"        else:",
			"            out.write(\" \"*counter+string+\";\")",
			"            out.write(i)",
			"            out.write(';'+string)",
			"            out.write(\"\\n\"+\" \"*counter+string+\";\")",
			"    except:",
			"        out.write(\" \"*counter)",
			"        out.write(i)",
			"    out.write('\\n')",
			""
		],
		"description": "plag remove "
	}
}
