{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"boilerplate": {
		"prefix": "boilerplate",
		"body": [
			"from itertools import combinations, permutations, combinations_with_replacement, product",
			"",
			"import itertools",
			"from timeit import timeit",
			"import timeit",
			"import time",
			"from time import time",
			"import collections",
			"import bisect",
			"import os",
			"import math",
			"from collections import defaultdict, OrderedDict, Counter",
			"from sys import stdin, stdout",
			"from bisect import bisect_left, bisect_right",
			"# import numpy as np",
			"from queue import Queue, PriorityQueue",
			"from heapq import *",
			"from statistics import *",
			"from math import sqrt, log10, log2, log, gcd, ceil, floor",
			"import fractions",
			"import copy",
			"from copy import deepcopy",
			"import sys",
			"import io",
			"import string",
			"from string import ascii_lowercase, ascii_uppercase, ascii_letters, digits",
			"sys.setrecursionlimit(10000)",
			"",
			"mod = int(pow(10, 9)) + 7",
			"",
			"",
			"def ncr(n, r, p=mod):",
			"    num = den = 1",
			"    for i in range(r):",
			"        num = (num * (n - i)) % p",
			"        den = (den * (i + 1)) % p",
			"    return (num * pow(den,",
			"                      p - 2, p)) % p",
			"",
			"",
			"def normalncr(n, r):",
			"    r = min(r, n - r)",
			"    count = 1",
			"    for i in range(n - r, n + 1):",
			"        count *= i",
			"",
			"    for i in range(1, r + 1):",
			"        count //= i",
			"    return count",
			"",
			"",
			"inf = float(\"inf\")",
			"adj = defaultdict(set)",
			"visited = defaultdict(int)",
			"",
			"",
			"def addedge(a, b):",
			"    adj[a].add(b)",
			"    adj[b].add(a)",
			"",
			"",
			"def bfs(v):",
			"    q = Queue()",
			"    q.put(v)",
			"    visited[v] = 1",
			"    while q.qsize() > 0:",
			"        s = q.get_nowait()",
			"        print(s)",
			"        for i in adj[s]:",
			"            if visited[i] == 0:",
			"                q.put(i)",
			"                visited[i] = 1",
			"",
			"",
			"def dfs(v, visited):",
			"    if visited[v] == 1:",
			"        return",
			"    visited[v] = 1",
			"",
			"    print(v)",
			"    for i in adj[v]:",
			"        dfs(i, visited)",
			"",
			"",
			"# a9=pow(10,5)+100",
			"# prime = [True for i in range(a9 + 1)]",
			"# def SieveOfEratosthenes(n):",
			"#     p = 2",
			"#     while (p * p <= n):",
			"#         if (prime[p] == True):",
			"#             for i in range(p * p, n + 1, p):",
			"#                 prime[i] = False",
			"#         p += 1",
			"# SieveOfEratosthenes(a9)",
			"# prime_number=[]",
			"# for i in range(2,a9):",
			"#     if prime[i]:",
			"#         prime_number.append(i)",
			"",
			"",
			"def reverse_bisect_right(a, x, lo=0, hi=None):",
			"    if lo < 0:",
			"        raise ValueError('lo must be non-negative')",
			"    if hi is None:",
			"        hi = len(a)",
			"    while lo < hi:",
			"        mid = (lo + hi) // 2",
			"        if x > a[mid]:",
			"            hi = mid",
			"        else:",
			"            lo = mid + 1",
			"    return lo",
			"",
			"",
			"def reverse_bisect_left(a, x, lo=0, hi=None):",
			"    if lo < 0:",
			"        raise ValueError('lo must be non-negative')",
			"    if hi is None:",
			"        hi = len(a)",
			"    while lo < hi:",
			"        mid = (lo + hi) // 2",
			"        if x >= a[mid]:",
			"            hi = mid",
			"        else:",
			"            lo = mid + 1",
			"    return lo",
			"",
			"",
			"def get_list():",
			"    return list(map(int, input().split()))",
			"",
			"",
			"def make_list(m):",
			"    m += list(map(int, input().split()))",
			"",
			"",
			"def get_str_list_in_int():",
			"    return [int(i) for i in list(input())]",
			"",
			"",
			"def get_str_list():",
			"    return list(input())",
			"",
			"",
			"def get_map():",
			"    return map(int, input().split())",
			"",
			"",
			"def input_int():",
			"    return int(input())",
			"",
			"",
			"def matrix(a, b):",
			"    return [[0 for i in range(b)] for j in range(a)]",
			"",
			"",
			"def swap(a, b):",
			"    return b, a",
			"",
			"",
			"def find_gcd(l):",
			"    a = l[0]",
			"    for i in range(len(l)):",
			"        a = gcd(a, l[i])",
			"    return a",
			"",
			"",
			"def is_prime(n):",
			"    sqrta = int(sqrt(n))",
			"    for i in range(2, sqrta + 1):",
			"        if n % i == 0:",
			"            return 0",
			"    return 1",
			"",
			"",
			"def prime_factors(n):",
			"    l = []",
			"    while n % 2 == 0:",
			"        l.append(2)",
			"        n //= 2",
			"    sqrta = int(sqrt(n))",
			"",
			"    for i in range(3, sqrta + 1, 2):",
			"        while n % i == 0:",
			"            n //= i",
			"            l.append(i)",
			"    if n > 2:",
			"        l.append(n)",
			"    return l",
			"",
			"",
			"def p(a):",
			"    if type(a) == str:",
			"        print(a + \"\\n\")",
			"    else:",
			"        print(str(a) + \"\\n\")",
			"",
			"",
			"def ps(a):",
			"    if type(a) == str:",
			"        print(a)",
			"    else:",
			"        print(str(a))",
			"",
			"",
			"def kth_no_not_div_by_n(n, k):",
			"    return k + (k - 1) // (n - 1)",
			"",
			"",
			"def forward_array(l):",
			"    \"\"\"",
			"    returns the forward index where the elemetn is just greater than that element",
			"    [100,200] gives [1,2]",
			"    because element at index 1 is greater than 100 and nearest",
			"    similarly if it is largest then it outputs n",
			"    :param l:",
			"    :return:",
			"    \"\"\"",
			"    n = len(l)",
			"    stack = []",
			"    forward = [0] * n",
			"    for i in range(len(l) - 1, -1, -1):",
			"        while len(stack) and l[stack[-1]] < l[i]:",
			"            stack.pop()",
			"        if len(stack) == 0:",
			"            forward[i] = len(l)",
			"        else:",
			"            forward[i] = stack[-1]",
			"        stack.append(i)",
			"    return forward",
			"",
			"",
			"def forward_array_notequal(l):",
			"    n = len(l)",
			"    stack = []",
			"    forward = [n]*n",
			"    for i in range(len(l) - 1, -1, -1):",
			"        while len(stack) and l[stack[-1]] <= l[i]:",
			"            stack.pop()",
			"        if len(stack) == 0:",
			"            forward[i] = len(l)",
			"        else:",
			"            forward[i] = stack[-1]",
			"        stack.append(i)",
			"    return forward",
			"",
			"",
			"def backward_array(l):",
			"    n = len(l)",
			"    stack = []",
			"    backward = [0] * n",
			"    for i in range(len(l)):",
			"        while len(stack) and l[stack[-1]] < l[i]:",
			"            stack.pop()",
			"        if len(stack) == 0:",
			"            backward[i] = -1",
			"        else:",
			"            backward[i] = stack[-1]",
			"        stack.append(i)",
			"    return backward",
			"",
			"",
			"def char(a):",
			"    return chr(a + 97)",
			"",
			"",
			"def get_length(a):",
			"    return 1 + int(log10(a))",
			"",
			"",
			"def issq(n):",
			"    sqrta = int(n ** 0.5)",
			"    return sqrta ** 2 == n",
			"",
			"",
			"def ceil(a, b):",
			"    return int((a+b-1)/b)",
			"",
			"",
			"def equal_sum_partition(arr, n):",
			"    sum = 0",
			"    for i in range(n):",
			"        sum += arr[i]",
			"    if sum % 2 != 0:",
			"        return False",
			"",
			"    part = [[True for i in range(n + 1)]",
			"            for j in range(sum // 2 + 1)]",
			"",
			"    for i in range(0, n + 1):",
			"        part[0][i] = True",
			"",
			"    for i in range(1, sum // 2 + 1):",
			"        part[i][0] = False",
			"",
			"    for i in range(1, sum // 2 + 1):",
			"",
			"        for j in range(1, n + 1):",
			"            part[i][j] = part[i][j - 1]",
			"",
			"            if i >= arr[j - 1]:",
			"                part[i][j] = (part[i][j] or",
			"                              part[i - arr[j - 1]][j - 1])",
			"",
			"    return part[sum // 2][n]",
			"",
			"",
			"def bin_sum_array(arr, n):",
			"    for i in range(n):",
			"        if arr[i] % 2 == 1:",
			"            return i+1",
			"    binarray = [list(reversed(bin(i)[2:])) for i in arr]",
			"    new_array = [0 for i in range(32)]",
			"    for i in binarray:",
			"        for j in range(len(i)):",
			"            if i[j] == '1':",
			"                new_array[j] += 1",
			"    return new_array",
			"",
			"",
			"def ispalindrome(s):",
			"    return s == s[::-1]",
			"",
			"",
			"def get_prefix(l):",
			"    if l == []:",
			"        return []",
			"    prefix = [l[0]]",
			"    for i in range(1, len(l)):",
			"        prefix.append(prefix[-1]+l[i])",
			"    return prefix",
			"",
			"",
			"def get_suffix(l):",
			"    if l == []:",
			"        return []",
			"    suffix = [l[-1]]*len(l)",
			"    for i in range(len(l)-2, -1, -1):",
			"        suffix[i] = suffix[i+1]+l[i]",
			"    return suffix",
			"",
			"",
			"nc = \"NO\"",
			"yc = \"YES\"",
			"ns = \"No\"",
			"ys = \"Yes\"",
			"",
			"",
			"def yesno(a):",
			"    print(yc if a else nc)",
			"",
			"",
			"def reduce(dict, a):",
			"    dict[a] -= 1",
			"    if dict[a] == 0:",
			"        dict.pop(a)",
			"",
			"",
			"# import math as mt",
			"# MAXN=10**7",
			"# spf = [0 for i in range(MAXN)]",
			"# def sieve():",
			"#     spf[1] = 1",
			"#     for i in range(2, MAXN):",
			"#         # marking smallest prime factor",
			"#         # for every number to be itself.",
			"#         spf[i] = i",
			"#",
			"#         # separately marking spf for",
			"#     # every even number as 2",
			"#     for i in range(4, MAXN, 2):",
			"#         spf[i] = 2",
			"#",
			"#     for i in range(3, mt.ceil(mt.sqrt(MAXN))):",
			"#",
			"#         # checking if i is prime",
			"#         if (spf[i] == i):",
			"#",
			"#             # marking SPF for all numbers",
			"#             # divisible by i",
			"#             for j in range(i * i, MAXN, i):",
			"#",
			"#                 # marking spf[j] if it is",
			"#                 # not previously marked",
			"#                 if (spf[j] == j):",
			"#                     spf[j] = i",
			"# def getFactorization(x):",
			"#     ret = list()",
			"#     while (x != 1):",
			"#         ret.append(spf[x])",
			"#         x = x // spf[x]",
			"#",
			"#     return ret",
			"# sieve()",
			"",
			"",
			"# if(os.path.exists('input.txt')):",
			"#     sys.stdin = open(\"input.txt\",\"r\") ; sys.stdout = open(\"output.txt\",\"w\")",
			"# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline",
			"input = sys.stdin.readline",
			"# print=sys.stdout.write",
			"t = 1",
			"",
			"t = int(input())",
			"for i in range(t):",
			"    n, k = get_list()",
			"    l = get_list()",
			""
		],
		"description": "boilerplate"
	},
	"small boilerplate": {
		"prefix": "small boilerplate",
		"body": [
			"import string",
			"from collections import defaultdict,Counter",
			"from math import sqrt, log10, log2, log, gcd, ceil, floor,factorial",
			"from bisect import bisect_left, bisect_right",
			"from itertools import combinations,combinations_with_replacement",
			"import sys,io,os",
			"input=sys.stdin.readline",
			"# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline",
			"# print=sys.stdout.write",
			"# sys.setrecursionlimit(10000)",
			"mod=10**9+7;inf = float('inf')",
			"def get_list(): return [int(i) for i in input().split()]",
			"def yn(a): print(\"YES\" if a else \"NO\",flush=False)",
			"t=int(input())",
			"for k in range(t):",
			"    n=int(input())",
			""
		],
		"description": "small boilerplate"
	},
	"infinite recursion": {
		"prefix": "recursion",
		"body": [
			"from types import GeneratorType",
			"",
			"",
			"def bootstrap(f, stack=[]):",
			"    def wrappedfunc(*args, **kwargs):",
			"        if stack:",
			"            return f(*args, **kwargs)",
			"        else:",
			"            to = f(*args, **kwargs)",
			"            while True:",
			"                if type(to) is GeneratorType:",
			"                    stack.append(to)",
			"                    to = next(to)",
			"                else:",
			"                    stack.pop()",
			"                    if not stack:",
			"                        break",
			"                    to = stack[-1].send(to)",
			"            return to",
			"",
			"    return wrappedfunc",
			"# @bootstrap",
			"# def fun(n):",
			"#     if n==0:",
			"#         yield",
			"#     yield fun(n-1)",
			"#     print(n)",
			"#     yield",
			"# ",
			"# fun(1000000)"
		],
		"description": "infinite recursion"
	},
	"bitset": {
		"prefix": "bitset",
		"body": [
			"class BitArray:",
			"    \"\"\"implements bitarray using bytearray\"\"\"",
			"    def __init__(self, size):",
			"        self.bytes = bytearray((size >> 3) + 1)",
			"",
			"    def __getitem__(self, index):",
			"        return (self.bytes[index >> 3] >> (index & 7)) & 1",
			"",
			"    def __setitem__(self, index, value):",
			"        if value:",
			"            self.bytes[index >> 3] |= 1 << (index & 7)",
			"        else:",
			"            self.bytes[index >> 3] &= ~(1 << (index & 7))"
		],
		"description": "bitset"
	},
	"disjoint set union": {
		"prefix": "disjoint set union",
		"body": [
			"class DisjointSetUnion:",
			"    def __init__(self, n):",
			"        self.parent = list(range(n))",
			"        self.size = [1] * n",
			"        self.num_sets = n",
			"",
			"    def find(self, a):",
			"        acopy = a",
			"        while a != self.parent[a]:",
			"            a = self.parent[a]",
			"        while acopy != a:",
			"            self.parent[acopy], acopy = a, self.parent[acopy]",
			"        return a",
			"",
			"    def union(self, a, b):",
			"        a, b = self.find(a), self.find(b)",
			"        if a != b:",
			"            if self.size[a] < self.size[b]:",
			"                a, b = b, a",
			"",
			"            self.num_sets -= 1",
			"            self.parent[b] = a",
			"            self.size[a] += self.size[b]",
			"            return 1",
			"        return 0",
			"",
			"    def set_size(self, a):",
			"        return self.size[self.find(a)]",
			"",
			"    def __len__(self):",
			"        return self.num_sets"
		],
		"description": "disjoint set union"
	},
	"disjoint set": {
		"prefix": "disjoint set",
		"body": [
			"class DisjointSetUnion:",
			"    def __init__(self, n):",
			"        self.parent = list(range(n))",
			"        self.size = [1] * n",
			"        self.num_sets = n",
			"",
			"    def find(self, a):",
			"        acopy = a",
			"        while a != self.parent[a]:",
			"            a = self.parent[a]",
			"        while acopy != a:",
			"            self.parent[acopy], acopy = a, self.parent[acopy]",
			"        return a",
			"",
			"    def union(self, a, b):",
			"        a, b = self.find(a), self.find(b)",
			"        if a != b:",
			"            if self.size[a] < self.size[b]:",
			"                a, b = b, a",
			"",
			"            self.num_sets -= 1",
			"            self.parent[b] = a",
			"            self.size[a] += self.size[b]",
			"",
			"    def set_size(self, a):",
			"        return self.size[self.find(a)]",
			"",
			"    def __len__(self):",
			"        return self.num_sets",
			"",
			"",
			"class UnionFind:",
			"    def __init__(self, n):",
			"        self.parent = list(range(n))",
			"",
			"    def find(self, a):",
			"        acopy = a",
			"        while a != self.parent[a]:",
			"            a = self.parent[a]",
			"        while acopy != a:",
			"            self.parent[acopy], acopy = a, self.parent[acopy]",
			"        return a",
			"",
			"    def union(self, a, b):",
			"        self.parent[self.find(b)] = self.find(a)"
		],
		"description": "disjoint set"
	},
	"count inversion": {
		"prefix": "inversion count",
		"body": [
			"class SortedList:",
			"    def __init__(self, iterable=[], _load=200):",
			"        \"\"\"Initialize sorted list instance.\"\"\"",
			"        values = sorted(iterable)",
			"        self._len = _len = len(values)",
			"        self._load = _load",
			"        self._lists = _lists = [values[i:i + _load]",
			"                                for i in range(0, _len, _load)]",
			"        self._list_lens = [len(_list) for _list in _lists]",
			"        self._mins = [_list[0] for _list in _lists]",
			"        self._fen_tree = []",
			"        self._rebuild = True",
			"",
			"    def _fen_build(self):",
			"        \"\"\"Build a fenwick tree instance.\"\"\"",
			"        self._fen_tree[:] = self._list_lens",
			"        _fen_tree = self._fen_tree",
			"        for i in range(len(_fen_tree)):",
			"            if i | i + 1 < len(_fen_tree):",
			"                _fen_tree[i | i + 1] += _fen_tree[i]",
			"        self._rebuild = False",
			"",
			"    def _fen_update(self, index, value):",
			"        \"\"\"Update `fen_tree[index] += value`.\"\"\"",
			"        if not self._rebuild:",
			"            _fen_tree = self._fen_tree",
			"            while index < len(_fen_tree):",
			"                _fen_tree[index] += value",
			"                index |= index + 1",
			"",
			"    def _fen_query(self, end):",
			"        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"",
			"        if self._rebuild:",
			"            self._fen_build()",
			"",
			"        _fen_tree = self._fen_tree",
			"        x = 0",
			"        while end:",
			"            x += _fen_tree[end - 1]",
			"            end &= end - 1",
			"        return x",
			"",
			"    def _fen_findkth(self, k):",
			"        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"",
			"        _list_lens = self._list_lens",
			"        if k < _list_lens[0]:",
			"            return 0, k",
			"        if k >= self._len - _list_lens[-1]:",
			"            return len(_list_lens) - 1, k + _list_lens[-1] - self._len",
			"        if self._rebuild:",
			"            self._fen_build()",
			"",
			"        _fen_tree = self._fen_tree",
			"        idx = -1",
			"        for d in reversed(range(len(_fen_tree).bit_length())):",
			"            right_idx = idx + (1 << d)",
			"            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:",
			"                idx = right_idx",
			"                k -= _fen_tree[idx]",
			"        return idx + 1, k",
			"",
			"    def _delete(self, pos, idx):",
			"        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"        _list_lens = self._list_lens",
			"",
			"        self._len -= 1",
			"        self._fen_update(pos, -1)",
			"        del _lists[pos][idx]",
			"        _list_lens[pos] -= 1",
			"",
			"        if _list_lens[pos]:",
			"            _mins[pos] = _lists[pos][0]",
			"        else:",
			"            del _lists[pos]",
			"            del _list_lens[pos]",
			"            del _mins[pos]",
			"            self._rebuild = True",
			"",
			"    def _loc_left(self, value):",
			"        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"",
			"        if not self._len:",
			"            return 0, 0",
			"",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"",
			"        lo, pos = -1, len(_lists) - 1",
			"        while lo + 1 < pos:",
			"            mi = (lo + pos) >> 1",
			"            if value <= _mins[mi]:",
			"                pos = mi",
			"            else:",
			"                lo = mi",
			"",
			"        if pos and value <= _lists[pos - 1][-1]:",
			"            pos -= 1",
			"",
			"        _list = _lists[pos]",
			"        lo, idx = -1, len(_list)",
			"        while lo + 1 < idx:",
			"            mi = (lo + idx) >> 1",
			"            if value <= _list[mi]:",
			"                idx = mi",
			"            else:",
			"                lo = mi",
			"",
			"        return pos, idx",
			"",
			"    def _loc_right(self, value):",
			"        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"",
			"        if not self._len:",
			"            return 0, 0",
			"",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"",
			"        pos, hi = 0, len(_lists)",
			"        while pos + 1 < hi:",
			"            mi = (pos + hi) >> 1",
			"            if value < _mins[mi]:",
			"                hi = mi",
			"            else:",
			"                pos = mi",
			"",
			"        _list = _lists[pos]",
			"        lo, idx = -1, len(_list)",
			"        while lo + 1 < idx:",
			"            mi = (lo + idx) >> 1",
			"            if value < _list[mi]:",
			"                idx = mi",
			"            else:",
			"                lo = mi",
			"",
			"        return pos, idx",
			"",
			"    def add(self, value):",
			"        \"\"\"Add `value` to sorted list.\"\"\"",
			"        _load = self._load",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"        _list_lens = self._list_lens",
			"",
			"        self._len += 1",
			"        if _lists:",
			"            pos, idx = self._loc_right(value)",
			"            self._fen_update(pos, 1)",
			"            _list = _lists[pos]",
			"            _list.insert(idx, value)",
			"            _list_lens[pos] += 1",
			"            _mins[pos] = _list[0]",
			"            if _load + _load < len(_list):",
			"                _lists.insert(pos + 1, _list[_load:])",
			"                _list_lens.insert(pos + 1, len(_list) - _load)",
			"                _mins.insert(pos + 1, _list[_load])",
			"                _list_lens[pos] = _load",
			"                del _list[_load:]",
			"                self._rebuild = True",
			"        else:",
			"            _lists.append([value])",
			"            _mins.append(value)",
			"            _list_lens.append(1)",
			"            self._rebuild = True",
			"",
			"    def discard(self, value):",
			"        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"",
			"        _lists = self._lists",
			"        if _lists:",
			"            pos, idx = self._loc_right(value)",
			"            if idx and _lists[pos][idx - 1] == value:",
			"                self._delete(pos, idx - 1)",
			"",
			"    def remove(self, value):",
			"        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"",
			"        _len = self._len",
			"        self.discard(value)",
			"        if _len == self._len:",
			"            raise ValueError('{0!r} not in list'.format(value))",
			"",
			"    def pop(self, index=-1):",
			"        \"\"\"Remove and return value at `index` in sorted list.\"\"\"",
			"        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
			"        value = self._lists[pos][idx]",
			"        self._delete(pos, idx)",
			"        return value",
			"",
			"    def bisect_left(self, value):",
			"        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"",
			"        pos, idx = self._loc_left(value)",
			"        return self._fen_query(pos) + idx",
			"",
			"    def bisect_right(self, value):",
			"        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"",
			"        pos, idx = self._loc_right(value)",
			"        return self._fen_query(pos) + idx",
			"",
			"    def count(self, value):",
			"        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"",
			"        return self.bisect_right(value) - self.bisect_left(value)",
			"",
			"    def __len__(self):",
			"        \"\"\"Return the size of the sorted list.\"\"\"",
			"        return self._len",
			"",
			"    def __getitem__(self, index):",
			"        \"\"\"Lookup value at `index` in sorted list.\"\"\"",
			"        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
			"        return self._lists[pos][idx]",
			"",
			"    def __delitem__(self, index):",
			"        \"\"\"Remove value at `index` from sorted list.\"\"\"",
			"        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
			"        self._delete(pos, idx)",
			"",
			"    def __contains__(self, value):",
			"        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"",
			"        _lists = self._lists",
			"        if _lists:",
			"            pos, idx = self._loc_left(value)",
			"            return idx < len(_lists[pos]) and _lists[pos][idx] == value",
			"        return False",
			"",
			"    def __iter__(self):",
			"        \"\"\"Return an iterator over the sorted list.\"\"\"",
			"        return (value for _list in self._lists for value in _list)",
			"",
			"    def __reversed__(self):",
			"        \"\"\"Return a reverse iterator over the sorted list.\"\"\"",
			"        return (value for _list in reversed(self._lists) for value in reversed(_list))",
			"",
			"    def __repr__(self):",
			"        \"\"\"Return string representation of sorted list.\"\"\"",
			"        return 'SortedList({0})'.format(list(self))",
			"",
			"",
			"def inversion_count(arr):",
			"    s = SortedList()",
			"    counter = 0",
			"    for i in reversed(arr):",
			"        s.add(i)",
			"        counter += s.bisect_left(i)",
			"    return counter",
			""
		],
		"description": "count inversion"
	},
	"sortedlist": {
		"prefix": "sortedlist",
		"body": [
			"class SortedList:",
			"    def __init__(self, iterable=[], _load=200):",
			"        \"\"\"Initialize sorted list instance.\"\"\"",
			"        values = sorted(iterable)",
			"        self._len = _len = len(values)",
			"        self._load = _load",
			"        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]",
			"        self._list_lens = [len(_list) for _list in _lists]",
			"        self._mins = [_list[0] for _list in _lists]",
			"        self._fen_tree = []",
			"        self._rebuild = True",
			" ",
			"    def _fen_build(self):",
			"        \"\"\"Build a fenwick tree instance.\"\"\"",
			"        self._fen_tree[:] = self._list_lens",
			"        _fen_tree = self._fen_tree",
			"        for i in range(len(_fen_tree)):",
			"            if i | i + 1 < len(_fen_tree):",
			"                _fen_tree[i | i + 1] += _fen_tree[i]",
			"        self._rebuild = False",
			" ",
			"    def _fen_update(self, index, value):",
			"        \"\"\"Update `fen_tree[index] += value`.\"\"\"",
			"        if not self._rebuild:",
			"            _fen_tree = self._fen_tree",
			"            while index < len(_fen_tree):",
			"                _fen_tree[index] += value",
			"                index |= index + 1",
			" ",
			"    def _fen_query(self, end):",
			"        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"",
			"        if self._rebuild:",
			"            self._fen_build()",
			" ",
			"        _fen_tree = self._fen_tree",
			"        x = 0",
			"        while end:",
			"            x += _fen_tree[end - 1]",
			"            end &= end - 1",
			"        return x",
			" ",
			"    def _fen_findkth(self, k):",
			"        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"",
			"        _list_lens = self._list_lens",
			"        if k < _list_lens[0]:",
			"            return 0, k",
			"        if k >= self._len - _list_lens[-1]:",
			"            return len(_list_lens) - 1, k + _list_lens[-1] - self._len",
			"        if self._rebuild:",
			"            self._fen_build()",
			" ",
			"        _fen_tree = self._fen_tree",
			"        idx = -1",
			"        for d in reversed(range(len(_fen_tree).bit_length())):",
			"            right_idx = idx + (1 << d)",
			"            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:",
			"                idx = right_idx",
			"                k -= _fen_tree[idx]",
			"        return idx + 1, k",
			" ",
			"    def _delete(self, pos, idx):",
			"        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"        _list_lens = self._list_lens",
			" ",
			"        self._len -= 1",
			"        self._fen_update(pos, -1)",
			"        del _lists[pos][idx]",
			"        _list_lens[pos] -= 1",
			" ",
			"        if _list_lens[pos]:",
			"            _mins[pos] = _lists[pos][0]",
			"        else:",
			"            del _lists[pos]",
			"            del _list_lens[pos]",
			"            del _mins[pos]",
			"            self._rebuild = True",
			" ",
			"    def _loc_left(self, value):",
			"        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"",
			"        if not self._len:",
			"            return 0, 0",
			" ",
			"        _lists = self._lists",
			"        _mins = self._mins",
			" ",
			"        lo, pos = -1, len(_lists) - 1",
			"        while lo + 1 < pos:",
			"            mi = (lo + pos) >> 1",
			"            if value <= _mins[mi]:",
			"                pos = mi",
			"            else:",
			"                lo = mi",
			" ",
			"        if pos and value <= _lists[pos - 1][-1]:",
			"            pos -= 1",
			" ",
			"        _list = _lists[pos]",
			"        lo, idx = -1, len(_list)",
			"        while lo + 1 < idx:",
			"            mi = (lo + idx) >> 1",
			"            if value <= _list[mi]:",
			"                idx = mi",
			"            else:",
			"                lo = mi",
			" ",
			"        return pos, idx",
			" ",
			"    def _loc_right(self, value):",
			"        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"",
			"        if not self._len:",
			"            return 0, 0",
			" ",
			"        _lists = self._lists",
			"        _mins = self._mins",
			" ",
			"        pos, hi = 0, len(_lists)",
			"        while pos + 1 < hi:",
			"            mi = (pos + hi) >> 1",
			"            if value < _mins[mi]:",
			"                hi = mi",
			"            else:",
			"                pos = mi",
			" ",
			"        _list = _lists[pos]",
			"        lo, idx = -1, len(_list)",
			"        while lo + 1 < idx:",
			"            mi = (lo + idx) >> 1",
			"            if value < _list[mi]:",
			"                idx = mi",
			"            else:",
			"                lo = mi",
			" ",
			"        return pos, idx",
			" ",
			"    def add(self, value):",
			"        \"\"\"Add `value` to sorted list.\"\"\"",
			"        _load = self._load",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"        _list_lens = self._list_lens",
			" ",
			"        self._len += 1",
			"        if _lists:",
			"            pos, idx = self._loc_right(value)",
			"            self._fen_update(pos, 1)",
			"            _list = _lists[pos]",
			"            _list.insert(idx, value)",
			"            _list_lens[pos] += 1",
			"            _mins[pos] = _list[0]",
			"            if _load + _load < len(_list):",
			"                _lists.insert(pos + 1, _list[_load:])",
			"                _list_lens.insert(pos + 1, len(_list) - _load)",
			"                _mins.insert(pos + 1, _list[_load])",
			"                _list_lens[pos] = _load",
			"                del _list[_load:]",
			"                self._rebuild = True",
			"        else:",
			"            _lists.append([value])",
			"            _mins.append(value)",
			"            _list_lens.append(1)",
			"            self._rebuild = True",
			" ",
			"    def discard(self, value):",
			"        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"",
			"        _lists = self._lists",
			"        if _lists:",
			"            pos, idx = self._loc_right(value)",
			"            if idx and _lists[pos][idx - 1] == value:",
			"                self._delete(pos, idx - 1)",
			" ",
			"    def remove(self, value):",
			"        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"",
			"        _len = self._len",
			"        self.discard(value)",
			"        if _len == self._len:",
			"            raise ValueError('{0!r} not in list'.format(value))",
			" ",
			"    def pop(self, index=-1):",
			"        \"\"\"Remove and return value at `index` in sorted list.\"\"\"",
			"        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
			"        value = self._lists[pos][idx]",
			"        self._delete(pos, idx)",
			"        return value",
			" ",
			"    def bisect_left(self, value):",
			"        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"",
			"        pos, idx = self._loc_left(value)",
			"        return self._fen_query(pos) + idx",
			" ",
			"    def bisect_right(self, value):",
			"        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"",
			"        pos, idx = self._loc_right(value)",
			"        return self._fen_query(pos) + idx",
			" ",
			"    def count(self, value):",
			"        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"",
			"        return self.bisect_right(value) - self.bisect_left(value)",
			" ",
			"    def __len__(self):",
			"        \"\"\"Return the size of the sorted list.\"\"\"",
			"        return self._len",
			" ",
			"    def __getitem__(self, index):",
			"        \"\"\"Lookup value at `index` in sorted list.\"\"\"",
			"        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
			"        return self._lists[pos][idx]",
			" ",
			"    def __delitem__(self, index):",
			"        \"\"\"Remove value at `index` from sorted list.\"\"\"",
			"        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
			"        self._delete(pos, idx)",
			" ",
			"    def __contains__(self, value):",
			"        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"",
			"        _lists = self._lists",
			"        if _lists:",
			"            pos, idx = self._loc_left(value)",
			"            return idx < len(_lists[pos]) and _lists[pos][idx] == value",
			"        return False",
			" ",
			"    def __iter__(self):",
			"        \"\"\"Return an iterator over the sorted list.\"\"\"",
			"        return (value for _list in self._lists for value in _list)",
			" ",
			"    def __reversed__(self):",
			"        \"\"\"Return a reverse iterator over the sorted list.\"\"\"",
			"        return (value for _list in reversed(self._lists) for value in reversed(_list))",
			" ",
			"    def __repr__(self):",
			"        \"\"\"Return string representation of sorted list.\"\"\"",
			"        return 'SortedList({0})'.format(list(self))"
		],
		"description": "sortedlist"
	},
	"sortedset": {
		"prefix": "sortedset",
		"body": [
			"class SortedSet:",
			"    def __init__(self, iterable=[], _load=200):",
			"        \"\"\"Initialize sorted list instance.\"\"\"",
			"        values = sorted(iterable)",
			"        self._len = _len = len(values)",
			"        self._load = _load",
			"        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]",
			"        self._list_lens = [len(_list) for _list in _lists]",
			"        self._mins = [_list[0] for _list in _lists]",
			"        self._fen_tree = []",
			"        self._rebuild = True",
			"",
			"    def _fen_build(self):",
			"        \"\"\"Build a fenwick tree instance.\"\"\"",
			"        self._fen_tree[:] = self._list_lens",
			"        _fen_tree = self._fen_tree",
			"        for i in range(len(_fen_tree)):",
			"            if i | i + 1 < len(_fen_tree):",
			"                _fen_tree[i | i + 1] += _fen_tree[i]",
			"        self._rebuild = False",
			"",
			"    def _fen_update(self, index, value):",
			"        \"\"\"Update `fen_tree[index] += value`.\"\"\"",
			"        if not self._rebuild:",
			"            _fen_tree = self._fen_tree",
			"            while index < len(_fen_tree):",
			"                _fen_tree[index] += value",
			"                index |= index + 1",
			"",
			"    def _fen_query(self, end):",
			"        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"",
			"        if self._rebuild:",
			"            self._fen_build()",
			"",
			"        _fen_tree = self._fen_tree",
			"        x = 0",
			"        while end:",
			"            x += _fen_tree[end - 1]",
			"            end &= end - 1",
			"        return x",
			"",
			"    def _fen_findkth(self, k):",
			"        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"",
			"        _list_lens = self._list_lens",
			"        if k < _list_lens[0]:",
			"            return 0, k",
			"        if k >= self._len - _list_lens[-1]:",
			"            return len(_list_lens) - 1, k + _list_lens[-1] - self._len",
			"        if self._rebuild:",
			"            self._fen_build()",
			"",
			"        _fen_tree = self._fen_tree",
			"        idx = -1",
			"        for d in reversed(range(len(_fen_tree).bit_length())):",
			"            right_idx = idx + (1 << d)",
			"            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:",
			"                idx = right_idx",
			"                k -= _fen_tree[idx]",
			"        return idx + 1, k",
			"",
			"    def _delete(self, pos, idx):",
			"        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"        _list_lens = self._list_lens",
			"",
			"        self._len -= 1",
			"        self._fen_update(pos, -1)",
			"        del _lists[pos][idx]",
			"        _list_lens[pos] -= 1",
			"",
			"        if _list_lens[pos]:",
			"            _mins[pos] = _lists[pos][0]",
			"        else:",
			"            del _lists[pos]",
			"            del _list_lens[pos]",
			"            del _mins[pos]",
			"            self._rebuild = True",
			"",
			"    def _loc_left(self, value):",
			"        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"",
			"        if not self._len:",
			"            return 0, 0",
			"",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"",
			"        lo, pos = -1, len(_lists) - 1",
			"        while lo + 1 < pos:",
			"            mi = (lo + pos) >> 1",
			"            if value <= _mins[mi]:",
			"                pos = mi",
			"            else:",
			"                lo = mi",
			"",
			"        if pos and value <= _lists[pos - 1][-1]:",
			"            pos -= 1",
			"",
			"        _list = _lists[pos]",
			"        lo, idx = -1, len(_list)",
			"        while lo + 1 < idx:",
			"            mi = (lo + idx) >> 1",
			"            if value <= _list[mi]:",
			"                idx = mi",
			"            else:",
			"                lo = mi",
			"",
			"        return pos, idx",
			"",
			"    def _loc_right(self, value):",
			"        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"",
			"        if not self._len:",
			"            return 0, 0",
			"",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"",
			"        pos, hi = 0, len(_lists)",
			"        while pos + 1 < hi:",
			"            mi = (pos + hi) >> 1",
			"            if value < _mins[mi]:",
			"                hi = mi",
			"            else:",
			"                pos = mi",
			"",
			"        _list = _lists[pos]",
			"        lo, idx = -1, len(_list)",
			"        while lo + 1 < idx:",
			"            mi = (lo + idx) >> 1",
			"            if value < _list[mi]:",
			"                idx = mi",
			"            else:",
			"                lo = mi",
			"",
			"        return pos, idx",
			"",
			"    def add(self, value):",
			"        \"\"\"Add `value` to sorted list.\"\"\"",
			"        if self.__contains__(value):",
			"            return",
			"        _load = self._load",
			"        _lists = self._lists",
			"        _mins = self._mins",
			"        _list_lens = self._list_lens",
			"",
			"        self._len += 1",
			"        if _lists:",
			"            pos, idx = self._loc_right(value)",
			"            self._fen_update(pos, 1)",
			"            _list = _lists[pos]",
			"            _list.insert(idx, value)",
			"            _list_lens[pos] += 1",
			"            _mins[pos] = _list[0]",
			"            if _load + _load < len(_list):",
			"                _lists.insert(pos + 1, _list[_load:])",
			"                _list_lens.insert(pos + 1, len(_list) - _load)",
			"                _mins.insert(pos + 1, _list[_load])",
			"                _list_lens[pos] = _load",
			"                del _list[_load:]",
			"                self._rebuild = True",
			"        else:",
			"            _lists.append([value])",
			"            _mins.append(value)",
			"            _list_lens.append(1)",
			"            self._rebuild = True",
			"",
			"    def discard(self, value):",
			"        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"",
			"        _lists = self._lists",
			"        if _lists:",
			"            pos, idx = self._loc_right(value)",
			"            if idx and _lists[pos][idx - 1] == value:",
			"                self._delete(pos, idx - 1)",
			"",
			"    def remove(self, value):",
			"        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"",
			"        _len = self._len",
			"        self.discard(value)",
			"        if _len == self._len:",
			"            raise ValueError('{0!r} not in list'.format(value))",
			"",
			"    def pop(self, index=-1):",
			"        \"\"\"Remove and return value at `index` in sorted list.\"\"\"",
			"        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
			"        value = self._lists[pos][idx]",
			"        self._delete(pos, idx)",
			"        return value",
			"",
			"    def bisect_left(self, value):",
			"        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"",
			"        pos, idx = self._loc_left(value)",
			"        return self._fen_query(pos) + idx",
			"",
			"    def bisect_right(self, value):",
			"        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"",
			"        pos, idx = self._loc_right(value)",
			"        return self._fen_query(pos) + idx",
			"",
			"    def count(self, value):",
			"        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"",
			"        return self.bisect_right(value) - self.bisect_left(value)",
			"",
			"    def __len__(self):",
			"        \"\"\"Return the size of the sorted list.\"\"\"",
			"        return self._len",
			"",
			"    def __getitem__(self, index):",
			"        \"\"\"Lookup value at `index` in sorted list.\"\"\"",
			"        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
			"        return self._lists[pos][idx]",
			"",
			"    def __delitem__(self, index):",
			"        \"\"\"Remove value at `index` from sorted list.\"\"\"",
			"        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
			"        self._delete(pos, idx)",
			"",
			"    def __contains__(self, value):",
			"        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"",
			"        _lists = self._lists",
			"        if _lists:",
			"            pos, idx = self._loc_left(value)",
			"            return idx < len(_lists[pos]) and _lists[pos][idx] == value",
			"        return False",
			"",
			"    def __iter__(self):",
			"        \"\"\"Return an iterator over the sorted list.\"\"\"",
			"        return (value for _list in self._lists for value in _list)",
			"",
			"    def __reversed__(self):",
			"        \"\"\"Return a reverse iterator over the sorted list.\"\"\"",
			"        return (value for _list in reversed(self._lists) for value in reversed(_list))",
			"",
			"    def __repr__(self):",
			"        \"\"\"Return string representation of sorted list.\"\"\"",
			"        return 'SortedList({0})'.format(list(self))"
		],
		"description": "sortedset"
	},
	"python fastio": {
		"prefix": "fastio",
		"body": [
			"import sys",
			"import os",
			"import io",
			"input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline",
			"# input = sys.stdin.readline",
			"# whenever s=input() is used replace it with s=input().strip() for rem \\n",
			""
		],
		"description": "python fastio"
	},
	"Equal sum partition python": {
		"prefix": "equal sum partition",
		"body": [
			"def equal_sum_partition(arr,n):",
			"    sum = 0",
			"    for i in range(n):",
			"        sum += arr[i]",
			"    if sum % 2 != 0:",
			"        return False",
			"",
			"    part = [[True for i in range(n + 1)]",
			"            for j in range(sum // 2 + 1)]",
			"",
			"    for i in range(0, n + 1):",
			"        part[0][i] = True",
			"",
			"    for i in range(1, sum // 2 + 1):",
			"        part[i][0] = False",
			"",
			"    for i in range(1, sum // 2 + 1):",
			"",
			"        for j in range(1, n + 1):",
			"            part[i][j] = part[i][j - 1]",
			"",
			"            if i >= arr[j - 1]:",
			"                part[i][j] = (part[i][j] or",
			"                              part[i - arr[j - 1]][j - 1])",
			"",
			"    return part[sum // 2][n]",
			"",
			"def bin_sum_array(arr,n):",
			"    for i in range(n):",
			"        if arr[i]%2==1:",
			"            return i+1",
			"    binarray=[list(reversed(bin(i)[2:])) for i in arr]",
			"    new_array=[0 for i in range(32)]",
			"    for i in binarray:",
			"        for j in range(len(i)):",
			"            if i[j]=='1':",
			"                new_array[j]+=1",
			"    return new_array"
		],
		"description": "Equal sum partition python"
	},
	"dijkstra algorithm": {
		"prefix": "dijkshtra with parent",
		"body": [
			"from heapq import heappop, heappush",
			"",
			"",
			"def dijkstra(graph, start):",
			"    \"\"\"",
			"        Uses Dijkstra's algortihm to find the shortest path from node start",
			"        to all other nodes in a directed weighted graph.",
			"    \"\"\"",
			"    \"\"\"",
			"        graph is like graph[0] contains [edge,weight] pairs",
			"        graph[0]=[[1,wt=100],[2,wt=2]]",
			"",
			"    \"\"\"",
			"    n = len(graph)",
			"    dist, parents = [float(\"inf\")] * n, [-1] * n",
			"    dist[start] = 0",
			"",
			"    queue = [(0, start)]",
			"    while queue:",
			"        path_len, v = heappop(queue)",
			"        if path_len == dist[v]:",
			"            for w, edge_len in graph[v]:",
			"                if edge_len + path_len < dist[w]:",
			"                    dist[w], parents[w] = edge_len + path_len, v",
			"                    heappush(queue, (edge_len + path_len, w))",
			"",
			"    return dist, parents",
			"",
			"",
			"# graph = [[[1, 100], [2, 500]], [[2, 100]], []]",
			"# src = 0",
			"# ans = dijkstra(graph, src)",
			"# print(ans)"
		],
		"description": "dijkstra algorithm"
	},
	"disjoint set union defaultdict": {
		"prefix": "disjoint set union defaultdict",
		"body": [
			"class DisjointSetUnion:",
			"    def __init__(self, n=0):",
			"        self.parent = defaultdict(int)",
			"        self.size = defaultdict(lambda :1)",
			"        self.num_sets = n",
			"    def add(self,val):",
			"        if val not in self.parent:",
			"            self.parent[val]=val",
			"            self.size[val]=1",
			"            self.num_sets+=1",
			"    def find(self, a):",
			"        acopy = a",
			"        while a != self.parent[a]:",
			"            a = self.parent[a]",
			"        while acopy != a:",
			"            self.parent[acopy], acopy = a, self.parent[acopy]",
			"        return a",
			"",
			"    def union(self, a, b):",
			"        a, b = self.find(a), self.find(b)",
			"        if a != b:",
			"            if self.size[a] < self.size[b]:",
			"                a, b = b, a",
			"",
			"            self.num_sets -= 1",
			"            self.parent[b] = a",
			"            self.size[a] += self.size[b]",
			"            return 1",
			"        return 0",
			"",
			"    def set_size(self, a):",
			"        return self.size[self.find(a)]",
			"",
			"    def __len__(self):",
			"        return self.num_sets"
		],
		"description": "disjoint set union defaultdict"
	},
	"cpp plag remove": {
		"prefix": "cpp plag",
		"body": [
			"file = open('cf.cpp', 'r')",
			"out = open('cf2.cpp', 'w')",
			"",
			"",
			"class string_generator:",
			"    def __init__(self):",
			"        self.count = 0",
			"        self.stringname = \"int randomvar\"",
			"        self.stringvalue = \"=0;\"",
			"        self.curly_brackets = 0",
			"",
			"    def get_string(self):",
			"        self.count += 1",
			"        return self.stringname+str(self.count)+self.stringvalue",
			"",
			"    def get_stringln(self):",
			"        return self.get_string()+\"\\n\"",
			"",
			"    def update_curly_bracket(self, s):",
			"        self.curly_brackets += s.count(\"{\")-s.count(\"}\")",
			"",
			"    def get_curly_bracket(self):",
			"        return self.curly_brackets",
			"",
			"",
			"var = string_generator()",
			"for i in file:",
			"    if i[-1] == '\\n':",
			"        i = i[:-1]",
			"    var.update_curly_bracket(i)",
			"    spacecount = 0",
			"    for counter in i:",
			"        if counter == \" \":",
			"            spacecount += 1",
			"        else:",
			"            break",
			"    i = i[spacecount:]",
			"    out.write(\" \"*spacecount)",
			"    if i.startswith(\"#\"):",
			"        out.write(var.get_stringln())",
			"    if i.startswith(\"for\"):",
			"        if var.get_curly_bracket():",
			"            out.write(var.get_stringln())",
			"        else:",
			"            out.write(var.get_string())",
			"    if i.startswith(\"while\"):",
			"        out.write(var.get_string())",
			"    if i.startswith(\"if\"):",
			"        out.write(var.get_string())",
			"",
			"    out.write(i)",
			"    try:",
			"        if len(i) == 0:",
			"            out.write(var.get_string())",
			"        elif i.endswith(';'):",
			"",
			"            out.write(var.get_string())",
			"            out.write(var.get_string())",
			"    except Exception as ex:",
			"        print(ex)",
			"    out.write('\\n')",
			""
		],
		"description": "cpp plag remove"
	},
	"count primes": {
		"prefix": "sieve for large number",
		"body": [
			"a9=int((10**4.5))+100",
			"prime = [True for i in range(a9 + 1)]",
			"def SieveOfEratosthenes(n):",
			"    p = 2",
			"    while (p * p <= n):",
			"        if (prime[p] == True):",
			"            for i in range(p * p, n + 1, p):",
			"                prime[i] = False",
			"        p += 1",
			"SieveOfEratosthenes(a9)",
			"prime_number=[]",
			"for i in range(2,a9):",
			"    if prime[i]:",
			"        prime_number.append(i)",
			"",
			"def countprimes(a):",
			"    count=0",
			"    for i in prime_number:",
			"        while a%i==0:",
			"            count+=1",
			"            a//=i;",
			"    if a>2:",
			"        count+=1",
			"    return count",
			""
		],
		"description": "count primes"
	},
	"plag remove": {
		"prefix": "plag remove",
		"body": [
			"file = open('cf.py', 'r')",
			"out = open('cf2.py', 'w')",
			"string = \"ali=0\"",
			"for i in file:",
			"    i = i[:-1]",
			"",
			"    if i and i[-1] == \";\":",
			"        i = i[:-1]",
			"",
			"    counter = 0",
			"    for j in i:",
			"",
			"        if j == ' ':",
			"            counter += 1",
			"        else:",
			"            break",
			"    i = i[counter:]",
			"    try:",
			"        if len(i) == 0:",
			"            out.write(\" \"*counter)",
			"            out.write(i)",
			"        elif i.endswith(','):",
			"            out.write(\" \"*counter)",
			"            out.write(i)",
			"        elif i.endswith(':'):",
			"            if i.startswith('if'):",
			"                out.write(\" \"*counter+string+\";\\n\")",
			"            out.write(\" \"*counter)",
			"            out.write(i)",
			"        elif i.startswith('def'):",
			"            out.write(\" \"*counter)",
			"            out.write(i)",
			"            out.write(';'+string)",
			"            out.write(\"\\n\"+\" \"*counter+string+\";\")",
			"        else:",
			"            out.write(\" \"*counter+string+\";\")",
			"            out.write(i)",
			"            out.write(';'+string)",
			"            out.write(\"\\n\"+\" \"*counter+string+\";\")",
			"    except:",
			"        out.write(\" \"*counter)",
			"        out.write(i)",
			"    out.write('\\n')",
			""
		],
		"description": "plag remove"
	},
	"fast sieve": {
		"prefix": "fast sieve",
		"body": [
			"def prime_sieve(n):",
			"    \"\"\"returns a sieve of primes >= 5 and < n\"\"\"",
			"    flag = n % 6 == 2",
			"    sieve = bytearray((n // 3 + flag >> 3) + 1)",
			"    for i in range(1, int(n**0.5) // 3 + 1):",
			"        if not (sieve[i >> 3] >> (i & 7)) & 1:",
			"            k = (3 * i + 1) | 1",
			"            for j in range(k * k // 3, n // 3 + flag, 2 * k):",
			"                sieve[j >> 3] |= 1 << (j & 7)",
			"            for j in range(k * (k - 2 * (i & 1) + 4) // 3, n // 3 + flag, 2 * k):",
			"                sieve[j >> 3] |= 1 << (j & 7)",
			"    return sieve",
			"",
			"",
			"def prime_list(n):",
			"    \"\"\"returns a list of primes <= n\"\"\"",
			"    res = []",
			"    if n > 1:",
			"        res.append(2)",
			"    if n > 2:",
			"        res.append(3)",
			"    if n > 4:",
			"        sieve = prime_sieve(n + 1)",
			"        res.extend(3 * i + 1 | 1 for i in range(1, (n + 1) // 3 +",
			"                                                (n % 6 == 1)) if not (sieve[i >> 3] >> (i & 7)) & 1)",
			"    return res",
			""
		],
		"description": "fast sieve"
	},
	"spf": {
		"prefix": "spf",
		"body": [
			"import math as mt",
			"MAXN=10**7",
			"spf = [0 for i in range(MAXN)]",
			"def sieve():",
			"    spf[1] = 1",
			"    for i in range(2, MAXN):",
			"        # marking smallest prime factor",
			"        # for every number to be itself.",
			"        spf[i] = i",
			"",
			"        # separately marking spf for",
			"    # every even number as 2",
			"    for i in range(4, MAXN, 2):",
			"        spf[i] = 2",
			"",
			"    for i in range(3, mt.ceil(mt.sqrt(MAXN))):",
			"",
			"        # checking if i is prime",
			"        if (spf[i] == i):",
			"",
			"            # marking SPF for all numbers",
			"            # divisible by i",
			"            for j in range(i * i, MAXN, i):",
			"",
			"                # marking spf[j] if it is",
			"                # not previously marked",
			"                if (spf[j] == j):",
			"                    spf[j] = i",
			"def getFactorization(x):",
			"    ret = list()",
			"    while (x != 1):",
			"        ret.append(spf[x])",
			"        x = x // spf[x]",
			"",
			"    return ret",
			"sieve()"
		],
		"description": "spf"
	},
	"sieve": {
		"prefix": "sieve",
		"body": [
			"a9=pow(10,5)+100",
			"prime = [True for i in range(a9 + 1)]",
			"def SieveOfEratosthenes(n):",
			"    p = 2",
			"    while (p * p <= n):",
			"        if (prime[p] == True):",
			"            for i in range(p * p, n + 1, p):",
			"                prime[i] = False",
			"        p += 1",
			"SieveOfEratosthenes(a9)",
			"prime_number=[]",
			"for i in range(2,a9):",
			"    if prime[i]:",
			"        prime_number.append(i)"
		],
		"description": "sieve"
	}
}
