{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"cpp boilerplate": {
		"prefix": "boilerplate",
		"body": [
			"#pragma GCC optimize(\"O2\")",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using namespace chrono;",
			"#define fastio                        \\",
			"    ios_base::sync_with_stdio(false); \\",
			"    cin.tie(NULL);                    \\",
			"    cout.tie(NULL);",
			"#define int long long",
			"#define lld long long",
			"#define p(x) cout << x << endl;",
			"#define p2(x, y) cout << x << \" \" << y << endl;",
			"#define p3(x, y, z) cout << x << \" \" << y << \" \" << z << endl;",
			"#define p4(x, y, z, a) cout << x << \" \" << y << \" \" << z << \" \" << a << endl;",
			"#define p5(x, y, z, a, b) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << endl;",
			"#define ps(x) cout << x << \" \";",
			"#define ps2(x, y) cout << x << \" \" << y << \" \";",
			"#define ps3(x, y, z) cout << x << \" \" << y << \" \" << z << \" \";",
			"#define ps4(x, y, z, a) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \";",
			"#define ps5(x, y, z, a, b) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << \" \";",
			"#define pns(x) cout << x;",
			"#define endl \"\\n\"",
			"#define all(x) x.begin(), x.end()",
			"#define dll(x) x.begin(), x.end(), greater<lld>()",
			"#define vect(x, n) vector<lld> x(n, 0);",
			"#define matrix(x, n, m) vector<vector<lld>> x(n, vector<lld>(m, 0));",
			"#define matrixs(x, n, m, o) vector<vector<vector<lld>>> x(n, vector<vector<lld>>(m, vector<lld>(o, 0)));",
			"#define gcd(a, b) __gcd(a, b)",
			"#define lcm(a, b) (a * b) / gcd(a, b)",
			"#define lb lower_bound",
			"#define ub upper_bound",
			"#define pb(x) push_back(x);",
			"#define pf(x) push_front(x);",
			"#define mkp(x, y) make_pair(x, y)",
			"#define f(i, a, b) for (lld i = (a); i < (b); i++)",
			"#define fr(i, a, b) for (lld i = (b); i > a; i--)",
			"#define inf 999999999999999",
			"#define pll pair<lld, lld>",
			"#define ppll pair<pll, lld>",
			"#define ff first",
			"#define ss second",
			"#define inp(v)                         \\",
			"    for (lld i = 0; i < v.size(); i++) \\",
			"    {                                  \\",
			"        cin >> v[i];                   \\",
			"    }",
			"#define MOD 1000000007",
			"#define mod 1000000007",
			"void addedge(unordered_map<lld, set<lld>> &adj, lld u, lld v)",
			"{",
			"    adj[u].insert(v);",
			"    adj[v].insert(u);",
			"}",
			"void dfs(unordered_map<lld, set<lld>> &adj, unordered_map<lld, lld> visited, lld v)",
			"{",
			"    visited[v] = 1;",
			"    p(v);",
			"    for (auto it = adj[v].begin(); it != adj[v].end(); it++)",
			"    {",
			"        if (visited[*it] == 0)",
			"        {",
			"            dfs(adj, visited, *it);",
			"        }",
			"    }",
			"}",
			"void bfs(unordered_map<lld, set<lld>> &adj, unordered_map<lld, lld> visited, lld v)",
			"{",
			"    visited[v] = 1;",
			"    queue<lld> q;",
			"    q.push(v);",
			"    while (q.empty() == 0)",
			"    {",
			"        lld s = q.front();",
			"        // p(s);",
			"        q.pop();",
			"",
			"        for (auto it = adj[s].begin(); it != adj[s].end(); it++)",
			"        {",
			"            if (visited[*it] == 0)",
			"            {",
			"                q.push(*it);",
			"                visited[*it] = 1;",
			"            }",
			"        }",
			"    }",
			"}",
			"struct cmpfunc",
			"{",
			"    bool operator()(const long &a, const long &b) const",
			"    {",
			"        return a > b;",
			"    }",
			"};",
			"lld pow(lld x, lld y, lld p)",
			"{",
			"    lld res = 1; // Initialize result",
			"",
			"    // Update x if it is more than or",
			"    // equal to p",
			"    x = x % p;",
			"",
			"    while (y > 0)",
			"    {",
			"        // If y is odd, multiply x with the result",
			"        if (y & 1)",
			"            res = (res * x) % p;",
			"",
			"        // y must be even now",
			"        y = y >> 1; // y = y/2",
			"        x = (x * x) % p;",
			"    }",
			"    return res;",
			"}",
			"lld pow(lld x, lld y)",
			"{",
			"    lld res = 1;",
			"    while (y > 0)",
			"    {",
			"        if (y & 1)",
			"            res = ((res) * (x));",
			"        y = y >> 1;",
			"        x = ((x) * (x));",
			"    }",
			"    return res;",
			"}",
			"string bin(lld n)",
			"{",
			"    // similar to bin(a)[2:] in python",
			"    string answer = \"\";",
			"    while (n)",
			"    {",
			"        if (n % 2 == 1)",
			"        {",
			"            answer += '1';",
			"        }",
			"        else",
			"        {",
			"            answer += '0';",
			"        }",
			"        n /= 2;",
			"    }",
			"    reverse(all(answer));",
			"    return answer;",
			"}",
			"lld bintodec(lld n)",
			"{",
			"    lld num = n;",
			"    lld dec_value = 0;",
			"",
			"    // Initializing base value to 1, i.e 2^0",
			"    lld base = 1;",
			"",
			"    lld temp = num;",
			"    while (temp)",
			"    {",
			"        lld last_digit = temp % 10;",
			"        temp = temp / 10;",
			"",
			"        dec_value += last_digit * base;",
			"",
			"        base = base * 2;",
			"    }",
			"",
			"    return dec_value;",
			"}",
			"string dectobin(lld n)",
			"{",
			"",
			"    //finding the binary form of the number and",
			"    //coneverting it to string.",
			"    string s = bitset<64>(n).to_string();",
			"",
			"    //Finding the first occurance of \"1\"",
			"    //to strip off the leading zeroes.",
			"    const auto loc1 = s.find('1');",
			"",
			"    if (loc1 != string::npos)",
			"        return s.substr(loc1);",
			"",
			"    return \"0\";",
			"}",
			"string binary32bit(lld n)",
			"{",
			"    string s = bitset<32>(n).to_string();",
			"    return s;",
			"}",
			"string binary64bit(lld n)",
			"{",
			"    string s = bitset<64>(n).to_string();",
			"    return s;",
			"}",
			"void print(vector<lld> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cout << v[i] << \" \";",
			"    }",
			"    cout << endl;",
			"}",
			"void print(vector<string> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cout << v[i] << \" \";",
			"    }",
			"    cout << endl;",
			"}",
			"void print(vector<pll> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cout << v[i].first << \" \" << v[i].second << \" \";",
			"    }",
			"    cout << endl;",
			"}",
			"void prints(vector<int> &v)",
			"{",
			"    //prints the vector from 1st index",
			"    for (int i = 1; i != v.size(); i++)",
			"    {",
			"        ps(v[i]);",
			"    }",
			"}",
			"void print(set<pair<int, int>> &seta)",
			"{",
			"    //prints the set it is used for debuggging",
			"    set<pair<int, int>>::iterator i;",
			"    for (i = seta.begin(); i != seta.end(); i++)",
			"    {",
			"        ps2(i->first, i->second);",
			"    }",
			"    p(\"\");",
			"}",
			"void print(map<int, int> &mapa)",
			"{",
			"    //prints the map it is used for debuggging",
			"    map<int, int>::iterator i;",
			"    for (i = mapa.begin(); i != mapa.end(); i++)",
			"    {",
			"        ps4(\"{\", i->first, i->second, \"}\");",
			"    }",
			"    p(\"\");",
			"}",
			"void print(set<int> &seta)",
			"{",
			"    //prints the set it is used for debuggging",
			"    set<int>::iterator i;",
			"    for (i = seta.begin(); i != seta.end(); i++)",
			"    {",
			"        ps(*i);",
			"    }",
			"    p(\"\");",
			"}",
			"void print(map<pair<int, int>, pair<int, int>> &mapa)",
			"{",
			"    //prints the map it is used for debuggging",
			"    map<pair<int, int>, pair<int, int>>::iterator i;",
			"    for (i = mapa.begin(); i != mapa.end(); i++)",
			"    {",
			"        ps4(i->first.first, i->first.second, i->second.first, i->second.second);",
			"    }",
			"}",
			"void print(map<pair<int, int>, int> &mapa)",
			"{",
			"    //prints the map it is used for debuggging",
			"    map<pair<int, int>, int>::iterator i;",
			"    for (i = mapa.begin(); i != mapa.end(); i++)",
			"    {",
			"        ps5(\"{\", i->first.first, i->first.second, i->second, \"}\");",
			"    }",
			"    p(\"\");",
			"}",
			"void print(pair<int, int> &tuple)",
			"{",
			"    //prints the tuple it is used for debuggging",
			"    p2(tuple.first, tuple.second);",
			"}",
			"void print(set<lld, greater<lld>> &s)",
			"{",
			"    for (auto i = s.begin(); i != s.end(); i++)",
			"    {",
			"        p(*i);",
			"    }",
			"}",
			"int min_index(vector<int> &cost)",
			"{",
			"    //returns the index of the min element of cost ie if min(cost)=4 then it returns index(4) in cost vector",
			"    int index = 0;",
			"    int min_cost = 0;",
			"    if (cost.size())",
			"    {",
			"        min_cost = cost[0];",
			"    }",
			"    for (int i = 0; i < cost.size(); i++)",
			"    {",
			"        if (min_cost > cost[i])",
			"        {",
			"            min_cost = cost[i];",
			"            index = i;",
			"        }",
			"    }",
			"    return index;",
			"}",
			"// const lld a3=1000000;",
			"// bool prime[a3 + 1];",
			"// void SieveOfEratosthenes(int n)",
			"// {",
			"",
			"//     memset(prime, true, sizeof(prime));",
			"",
			"//     for (int p = 2; p * p <= n; p++)",
			"//     {",
			"//         if (prime[p] == true)",
			"//         {",
			"",
			"//             for (int i = p * p; i <= n; i += p)",
			"//                 prime[i] = false;",
			"//         }",
			"//     }",
			"// }",
			"void Counter(vector<lld> &v, unordered_map<lld, lld> &um)",
			"{",
			"    for (int i : v)",
			"    {",
			"        um[i] += 1;",
			"    }",
			"}",
			"unordered_map<lld, lld> Counter(vector<lld> &v)",
			"{",
			"    unordered_map<lld, lld> um;",
			"    for (int i : v)",
			"    {",
			"        um[i] += 1;",
			"    }",
			"    return um;",
			"}",
			"unordered_map<char, lld> Counter(string &a)",
			"{",
			"    unordered_map<char, lld> um;",
			"    for (char i : a)",
			"    {",
			"        um[i] += 1;",
			"    }",
			"    return um;",
			"}",
			"void get_list(vector<lld> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cin >> v[i];",
			"    }",
			"}",
			"vector<lld> sliced(vector<lld> &v, lld start, lld end)",
			"{",
			"    vector<lld> another;",
			"    f(i, start, end)",
			"    {",
			"        another.pb(v[i]);",
			"    }",
			"    return another;",
			"}",
			"vector<lld> sliced(vector<lld> &v, lld start)",
			"{",
			"    vector<lld> another;",
			"    f(i, start, v.size())",
			"    {",
			"        another.pb(v[i]);",
			"    }",
			"    return another;",
			"}",
			"void ignore(lld a)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p(a);",
			"#endif",
			"}",
			"void ignore(lld a, lld b)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p2(a, b);",
			"#endif",
			"}",
			"void ignore(lld a, lld b, lld c)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p3(a, b, c);",
			"#endif",
			"}",
			"void ignore(lld a, lld b, lld c, lld d)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p4(a, b, c, d);",
			"#endif",
			"}",
			"void ignore(lld a, lld b, lld c, lld d, lld e)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p5(a, b, c, d, e);",
			"#endif",
			"}",
			"lld kth_no_not_divisible_by_n(lld n, lld k)",
			"{",
			"    return k + (k - 1) / (n - 1);",
			"}",
			"lld ceil(lld a, lld n)",
			"{",
			"",
			"    return (a + n - 1) / n;",
			"}",
			"lld get_mod(lld a, lld b)",
			"{",
			"    lld answer = a % b;",
			"    if (answer < 0)",
			"    {",
			"        return answer + b;",
			"    }",
			"    return answer;",
			"}",
			"",
			"string nc = \"NO\";",
			"string ns = \"No\";",
			"string yc = \"YES\";",
			"string ys = \"Yes\";",
			"map<lld, lld> m;",
			"void yesno(lld a)",
			"{",
			"    if (a)",
			"    {",
			"        p(yc);",
			"    }",
			"    else",
			"    {",
			"        p(nc);",
			"    }",
			"}",
			"void fun()",
			"{",
			"    string a = binary64bit(10);",
			"    p(a);",
			"}",
			"signed main()",
			"{",
			"    fastio;",
			"    auto start1 = high_resolution_clock::now();",
			"",
			"    lld t;",
			"    t = 1;",
			"    cin >> t;",
			"",
			"    while (t--)",
			"    {",
			"        fun();",
			"    }",
			"",
			"    auto stop1 = high_resolution_clock::now();",
			"    auto duration = duration_cast<microseconds>(stop1 - start1);",
			"#ifndef ONLINE_JUDGE",
			"    cerr << \"Time: \" << duration.count() / 1000.0 << endl;",
			"    cout << duration.count() / 1000.0 << endl;",
			"#endif",
			"}"
		],
		"description": "cpp boilerplate"
	},
	"Bellman ford": {
		"prefix": "bellman",
		"body": [
			"void bellman(lld n, vector<vector<pair<lld, lld>>> adj, vector<lld> &distance, lld &negative_cycle_found)",
			"{",
			"    lld s = n + 1;",
			"    //we run bellman ford from alpha=n+1;",
			"    lld relax_edge_modification = 0;",
			"    distance[s] = 0;",
			"    //distance of source is 0",
			"    vector<lld> times_pushed_in_queue(n + 2, 0);",
			"    vector<lld> count(n + 2, 0);",
			"    queue<lld> queue;",
			"    queue.push(s);",
			"    times_pushed_in_queue[s]++;",
			"    lld previous_element = s;",
			"    lld previous_relax_modification = 0;",
			"    lld element, adjacent, dista;",
			"    vector<pair<lld, lld>>::iterator i;",
			"    for (lld times = 1; times <= n + 1; times++)",
			"    {",
			"        //we will run the loop n+1 times as there are n vertices and one alpha;",
			"        previous_relax_modification = relax_edge_modification;",
			"        while (queue.empty() == 0)",
			"        {",
			"            element = queue.front();",
			"            if ((times_pushed_in_queue[element] - 1) / 2 > times)",
			"            {",
			"                //our next iteration must start so we break here;",
			"                break;",
			"            }",
			"            queue.pop();",
			"            times_pushed_in_queue[element]++;",
			"",
			"            for (i = adj[element].begin(); i != adj[element].end(); i++)",
			"            {",
			"                adjacent = i->second;",
			"                dista = i->first;",
			"                if (distance[adjacent] > dista + distance[element])",
			"                {",
			"                    distance[adjacent] = dista + distance[element];",
			"                    relax_edge_modification++;",
			"                    count[adjacent] = count[element] + 1;",
			"                    if (count[adjacent] > n - 1 + 1)",
			"                    {",
			"                        negative_cycle_found = 1;",
			"                        p(-1);",
			"                        return;",
			"                    }",
			"                    if (times_pushed_in_queue[adjacent] % 2 == 0)",
			"                    {",
			"                        queue.push(adjacent);",
			"                        times_pushed_in_queue[adjacent]++;",
			"                    }",
			"                }",
			"            }",
			"            previous_element = element;",
			"        }",
			"        if (times == n + 1)",
			"        {",
			"            if (previous_relax_modification < relax_edge_modification)",
			"            {",
			"                //if in the n+1th iteration we get relax edge modification then there is a negative cycle so we return;",
			"                p(-1);",
			"                return;",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "Bellman ford"
	},
	"Dijkshtra binary heap based": {
		"prefix": "Dijkshtra",
		"body": [
			"void change(vector<vector<pair<lld, lld>>> &adj_changed, vector<lld> distance)",
			"{",
			"    //used to find delta after running bellman ford;",
			"    for (lld i = 0; i < adj_changed.size(); i++)",
			"    {",
			"        for (lld j = 0; j < adj_changed[i].size(); j++)",
			"        {",
			"            if (adj_changed[i][j].first != inf)",
			"                adj_changed[i][j].first += distance[i] - distance[adj_changed[i][j].second];",
			"        }",
			"    }",
			"}",
			"void minimum_heapify(vector<pair<lld, lld>> &v, lld n, lld i, vector<lld> &address)",
			"{",
			"    //heapify the vector;",
			"    lld smallest = i;",
			"    lld left = 2 * smallest + 1;",
			"    lld right = 2 * smallest + 2;",
			"    lld a = left < n;",
			"    if (left < n && v[smallest] > v[left])",
			"    {",
			"        smallest = left;",
			"    }",
			"    lld b = right < n;",
			"    if (right < n && v[smallest] > v[right])",
			"    {",
			"        smallest = right;",
			"    }",
			"    lld go = smallest != i;",
			"    if (go)",
			"    {",
			"        //we swap the element if the parent is larger than any child",
			"        swap(v[i], v[smallest]);",
			"        //we also swap the address of them",
			"        swap(address[v[i].second], address[v[smallest].second]);",
			"        minimum_heapify(v, n, smallest, address);",
			"    }",
			"}",
			"lld parent(lld i)",
			"{",
			"    //returns parent;",
			"    return (i - 1) / 2;",
			"}",
			"void shift_up(vector<pair<lld, lld>> &v, lld n, lld i, vector<lld> &address)",
			"{",
			"    while (i > 0 && v[parent(i)] > v[i])",
			"    {",
			"        // Swap parent and current node",
			"        swap(v[parent(i)], v[i]);",
			"        swap(address[v[parent(i)].second], address[v[i].second]);",
			"        // Update i to parent of i",
			"        i = parent(i);",
			"    }",
			"}",
			"pair<lld, lld> get_min(vector<pair<lld, lld>> v)",
			"{",
			"    //the minimum element in heap is v[0]",
			"    return v[0];",
			"}",
			"void swaps(pair<lld, lld> &a, pair<lld, lld> &b)",
			"{",
			"    pair<lld, lld> e = a;",
			"    a = b;",
			"    b = e;",
			"}",
			"pair<lld, lld> extract_min(vector<pair<lld, lld>> &v, lld &size, vector<lld> &address)",
			"{",
			"    static pair<lld, lld> maxa = v[0];",
			"    swaps(v[0], v[size - 1]);",
			"    swap(address[v[0].second], address[v[size - 1].second]);",
			"    v[size - 1].first = inf;",
			"    size--;",
			"    minimum_heapify(v, size, 0, address);",
			"    return maxa;",
			"}",
			"void push_back(vector<pair<lld, lld>> &v, lld &size, pair<lld, lld> data, vector<lld> &address)",
			"{",
			"    address[data.second] = size;",
			"    v[size++] = data;",
			"    shift_up(v, size, size - 1, address);",
			"}",
			"void decrease_key(vector<pair<lld, lld>> &v, lld &size, lld n, pair<lld, lld> data, pair<lld, lld> new_data, vector<lld> &address)",
			"{",
			"    lld i = address[data.second];",
			"    v[i] = new_data;",
			"    shift_up(v, n, i, address);",
			"}",
			"lld empty(vector<pair<lld, lld>> v, lld n)",
			"{",
			"    if (v[0].first != inf)",
			"    {",
			"        return 0;",
			"    }",
			"    return 1;",
			"}",
			"void binary_heap_based_dijkstra(lld n, vector<vector<pair<lld, lld>>> adj, lld s, vector<lld> changed_distance)",
			"{",
			"    vector<pair<lld, lld>> v(n + 2);",
			"    lld size = 0;",
			"    lld size_of_arr = v.size();",
			"    vector<lld> address(n + 2);",
			"    for (lld i = 0; i < size_of_arr; i++)",
			"    {",
			"        if (i == s)",
			"        {",
			"            //if it is source we insert 0",
			"            pair<lld, lld> data = {0, s};",
			"            push_back(v, size, data, address);",
			"        }",
			"        else",
			"        {",
			"            //else if it is not source we insert all distances",
			"            pair<lld, lld> data = {inf, i};",
			"            push_back(v, size, data, address);",
			"        }",
			"    }",
			"    vector<lld> distance(n + 2, inf);",
			"    distance[s] = 0;",
			"    vector<lld> shortest_path_fount(n + 2, 0);",
			"    shortest_path_fount[s] = 1;",
			"    vector<lld> present(n + 2);",
			"    vector<pair<lld, lld>>::iterator i;",
			"    pair<lld, lld> top_element;",
			"    while (empty(v, n) == 0)",
			"    {",
			"        //get min returns the vertex having minimum wt in the form of {wt,vertex}",
			"        top_element = get_min(v);",
			"        lld element = top_element.second;",
			"        lld dist = top_element.first;",
			"        extract_min(v, size, address);",
			"        for (i = adj[element].begin(); i != adj[element].end(); i++)",
			"        {",
			"            lld adjacent = i->second;",
			"            lld dista = i->first;",
			"            if (shortest_path_fount[adjacent] == 0 && distance[element] != inf && distance[adjacent] > dista + distance[element])",
			"            {",
			"                decrease_key(v, size, n + 2, {distance[adjacent], adjacent}, {dista + distance[element], adjacent}, address);",
			"                distance[adjacent] = dista + distance[element];",
			"            }",
			"        }",
			"        shortest_path_fount[element] = 1;",
			"    }",
			"    for (lld i = 1; i < n + 1; i++)",
			"    {",
			"        if (same(i, s))",
			"        {",
			"            ps(0);",
			"        }",
			"        else if (same(distance[i], inf))",
			"        {",
			"            ps(inf);",
			"        }",
			"        else",
			"        {",
			"            lld corrected = distance[i] - changed_distance[s] + changed_distance[i];",
			"            ps(corrected);",
			"        }",
			"    }",
			"    p(\"\");",
			"}"
		],
		"description": "Dijkshtra binary heap based"
	},
	"sieve of eratosthenes": {
		"prefix": "sieve",
		"body": [
			"const lld a3 = 1000000;",
			"bool prime[a3 + 1];",
			"void SieveOfEratosthenes(int n)",
			"{",
			"",
			"    memset(prime, true, sizeof(prime));",
			"",
			"    for (int p = 2; p * p <= n; p++)",
			"    {",
			"        if (prime[p] == true)",
			"        {",
			"",
			"            for (int i = p * p; i <= n; i += p)",
			"                prime[i] = false;",
			"        }",
			"    }",
			"}"
		],
		"description": "sieve of eratosthenes"
	},
	"Leetcode boilerplate": {
		"prefix": "Leetcode",
		"body": [
			"#pragma GCC optimize(\"O2\")",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using namespace chrono;",
			"#define fastio                        \\",
			"    ios_base::sync_with_stdio(false); \\",
			"    cin.tie(NULL);                    \\",
			"    cout.tie(NULL);",
			"#define int long long",
			"#define lld long long",
			"#define tr(i, x) for (auto i : x)",
			"#define p(x) cout << x << endl;",
			"#define p2(x, y) cout << x << \" \" << y << endl;",
			"#define p3(x, y, z) cout << x << \" \" << y << \" \" << z << endl;",
			"#define p4(x, y, z, a) cout << x << \" \" << y << \" \" << z << \" \" << a << endl;",
			"#define p5(x, y, z, a, b) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << endl;",
			"#define ps(x) cout << x << \" \";",
			"#define ps2(x, y) cout << x << \" \" << y << \" \";",
			"#define ps3(x, y, z) cout << x << \" \" << y << \" \" << z << \" \";",
			"#define ps4(x, y, z, a) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \";",
			"#define ps5(x, y, z, a, b) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << \" \";",
			"#define pns(x) cout << x;",
			"#define endl \"\\n\"",
			"#define all(x) x.begin(), x.end()",
			"#define dll(x) x.begin(), x.end(), greater<lld>()",
			"#define vect(x, n) vector<lld> x(n, 0);",
			"#define matrix(x, n, m) vector<vector<lld>> x(n, vector<lld>(m, 0));",
			"#define gcd(a, b) __gcd(a, b)",
			"#define lcm(a, b) (a * b) / gcd(a, b)",
			"#define lb lower_bound",
			"#define ub upper_bound",
			"#define pb(x) push_back(x);",
			"#define pf(x) push_front(x);",
			"#define mkp(x, y) make_pair(x, y)",
			"#define f(i, a, b) for (lld i = (a); i < (b); i++)",
			"#define fr(i, a, b) for (lld i = (b); i > a; i--)",
			"#define inf 999999999999999",
			"#define pll pair<lld, lld>",
			"#define ppll pair<pll, lld>",
			"#define ff first",
			"#define ss second",
			"#define mod 1000000007",
			"void addedge(unordered_map<lld, set<lld>> &adj, lld u, lld v)",
			"{",
			"    adj[u].insert(v);",
			"    adj[v].insert(u);",
			"}",
			"void dfs(unordered_map<lld, set<lld>> &adj, unordered_map<lld, lld> visited, lld v)",
			"{",
			"    visited[v] = 1;",
			"    p(v);",
			"    for (auto it = adj[v].begin(); it != adj[v].end(); it++)",
			"    {",
			"        if (visited[*it] == 0)",
			"        {",
			"            dfs(adj, visited, *it);",
			"        }",
			"    }",
			"}",
			"void bfs(unordered_map<lld, set<lld>> &adj, unordered_map<lld, lld> visited, lld v)",
			"{",
			"    visited[v] = 1;",
			"    queue<lld> q;",
			"    q.push(v);",
			"    while (q.empty() == 0)",
			"    {",
			"        lld s = q.front();",
			"        // p(s);",
			"        q.pop();",
			"",
			"        for (auto it = adj[s].begin(); it != adj[s].end(); it++)",
			"        {",
			"            if (visited[*it] == 0)",
			"            {",
			"                q.push(*it);",
			"                visited[*it] = 1;",
			"            }",
			"        }",
			"    }",
			"}",
			"struct cmpfunc",
			"{",
			"    bool operator()(const long &a, const long &b) const",
			"    {",
			"        return a > b;",
			"    }",
			"};",
			"lld pow(lld x, lld y, lld p)",
			"{",
			"    lld res = 1; // Initialize result",
			"",
			"    // Update x if it is more than or",
			"    // equal to p",
			"    x = x % p;",
			"",
			"    while (y > 0)",
			"    {",
			"        // If y is odd, multiply x with the result",
			"        if (y & 1)",
			"            res = (res * x) % p;",
			"",
			"        // y must be even now",
			"        y = y >> 1; // y = y/2",
			"        x = (x * x) % p;",
			"    }",
			"    return res;",
			"}",
			"lld pow(lld x, lld y)",
			"{",
			"    lld res = 1;",
			"    while (y > 0)",
			"    {",
			"        if (y & 1)",
			"            res = ((res) * (x));",
			"        y = y >> 1;",
			"        x = ((x) * (x));",
			"    }",
			"    return res;",
			"}",
			"lld bintodec(lld n)",
			"{",
			"    lld num = n;",
			"    lld dec_value = 0;",
			"",
			"    // Initializing base value to 1, i.e 2^0",
			"    lld base = 1;",
			"",
			"    lld temp = num;",
			"    while (temp)",
			"    {",
			"        lld last_digit = temp % 10;",
			"        temp = temp / 10;",
			"",
			"        dec_value += last_digit * base;",
			"",
			"        base = base * 2;",
			"    }",
			"",
			"    return dec_value;",
			"}",
			"string dectobin(lld n)",
			"{",
			"",
			"    //finding the binary form of the number and",
			"    //coneverting it to string.",
			"    string s = bitset<64>(n).to_string();",
			"",
			"    //Finding the first occurance of \"1\"",
			"    //to strip off the leading zeroes.",
			"    const auto loc1 = s.find('1');",
			"",
			"    if (loc1 != string::npos)",
			"        return s.substr(loc1);",
			"",
			"    return \"0\";",
			"}",
			"void print(vector<lld> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cout << v[i] << \" \";",
			"    }",
			"    cout << endl;",
			"}",
			"void print(vector<string> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cout << v[i] << \" \";",
			"    }",
			"    cout << endl;",
			"}",
			"void print(vector<pll> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cout << v[i].first << \" \" << v[i].second << \" \";",
			"    }",
			"    cout << endl;",
			"}",
			"void prints(vector<int> &v)",
			"{",
			"    //prints the vector from 1st index",
			"    for (int i = 1; i != v.size(); i++)",
			"    {",
			"        ps(v[i]);",
			"    }",
			"}",
			"void print(set<pair<int, int>> &seta)",
			"{",
			"    //prints the set it is used for debuggging",
			"    set<pair<int, int>>::iterator i;",
			"    for (i = seta.begin(); i != seta.end(); i++)",
			"    {",
			"        ps2(i->first, i->second);",
			"    }",
			"    p(\"\");",
			"}",
			"void print(map<int, int> &mapa)",
			"{",
			"    //prints the map it is used for debuggging",
			"    map<int, int>::iterator i;",
			"    for (i = mapa.begin(); i != mapa.end(); i++)",
			"    {",
			"        ps4(\"{\", i->first, i->second, \"}\");",
			"    }",
			"    p(\"\");",
			"}",
			"void print(set<int> &seta)",
			"{",
			"    //prints the set it is used for debuggging",
			"",
			"    for (auto i = seta.begin(); i != seta.end(); i++)",
			"    {",
			"        ps(*i);",
			"    }",
			"    p(\"\");",
			"}",
			"void print(map<pair<int, int>, pair<int, int>> &mapa)",
			"{",
			"    //prints the map it is used for debuggging",
			"    map<pair<int, int>, pair<int, int>>::iterator i;",
			"    for (i = mapa.begin(); i != mapa.end(); i++)",
			"    {",
			"        ps4(i->first.first, i->first.second, i->second.first, i->second.second);",
			"    }",
			"}",
			"void print(map<pair<int, int>, int> &mapa)",
			"{",
			"    //prints the map it is used for debuggging",
			"    map<pair<int, int>, int>::iterator i;",
			"    for (i = mapa.begin(); i != mapa.end(); i++)",
			"    {",
			"        ps5(\"{\", i->first.first, i->first.second, i->second, \"}\");",
			"    }",
			"    p(\"\");",
			"}",
			"void print(pair<int, int> &tuple)",
			"{",
			"    //prints the tuple it is used for debuggging",
			"    p2(tuple.first, tuple.second);",
			"}",
			"void print(set<lld, greater<lld>> &s)",
			"{",
			"    for (auto i = s.begin(); i != s.end(); i++)",
			"    {",
			"        p(*i);",
			"    }",
			"}",
			"int min_index(vector<int> &cost)",
			"{",
			"    //returns the index of the min element of cost ie if min(cost)=4 then it returns index(4) in cost vector",
			"    int index = 0;",
			"    int min_cost = 0;",
			"    if (cost.size())",
			"    {",
			"        min_cost = cost[0];",
			"    }",
			"    for (int i = 0; i < cost.size(); i++)",
			"    {",
			"        if (min_cost > cost[i])",
			"        {",
			"            min_cost = cost[i];",
			"            index = i;",
			"        }",
			"    }",
			"    return index;",
			"}",
			"// const lld a3=1000000;",
			"// bool prime[a3 + 1];",
			"// void SieveOfEratosthenes(int n)",
			"// {",
			"",
			"//     memset(prime, true, sizeof(prime));",
			"",
			"//     for (int p = 2; p * p <= n; p++)",
			"//     {",
			"//         if (prime[p] == true)",
			"//         {",
			"",
			"//             for (int i = p * p; i <= n; i += p)",
			"//                 prime[i] = false;",
			"//         }",
			"//     }",
			"// }",
			"void Counter(vector<lld> &v, unordered_map<lld, lld> &um)",
			"{",
			"    for (int i : v)",
			"    {",
			"        um[i] += 1;",
			"    }",
			"}",
			"unordered_map<lld, lld> Counter(vector<lld> &v)",
			"{",
			"    unordered_map<lld, lld> um;",
			"    for (int i : v)",
			"    {",
			"        um[i] += 1;",
			"    }",
			"    return um;",
			"}",
			"unordered_map<char, lld> Counter(string &a)",
			"{",
			"    unordered_map<char, lld> um;",
			"    for (char i : a)",
			"    {",
			"        um[i] += 1;",
			"    }",
			"    return um;",
			"}",
			"void get_list(vector<lld> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cin >> v[i];",
			"    }",
			"}",
			"vector<lld> sliced(vector<lld> &v, lld start, lld end)",
			"{",
			"    vector<lld> another;",
			"    f(i, start, end)",
			"    {",
			"        another.pb(v[i]);",
			"    }",
			"    return another;",
			"}",
			"vector<lld> sliced(vector<lld> &v, lld start)",
			"{",
			"    vector<lld> another;",
			"    f(i, start, v.size())",
			"    {",
			"        another.pb(v[i]);",
			"    }",
			"    return another;",
			"}",
			"void ignore(lld a)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p(a);",
			"#endif",
			"}",
			"void ignore(lld a, lld b)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p2(a, b);",
			"#endif",
			"}",
			"void ignore(lld a, lld b, lld c)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p3(a, b, c);",
			"#endif",
			"}",
			"void ignore(lld a, lld b, lld c, lld d)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p4(a, b, c, d);",
			"#endif",
			"}",
			"void ignore(lld a, lld b, lld c, lld d, lld e)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p5(a, b, c, d, e);",
			"#endif",
			"}",
			"lld kth_no_not_divisible_by_n(lld n, lld k)",
			"{",
			"    return k + (k - 1) / (n - 1);",
			"}",
			"lld ceil(lld a, lld b)",
			"{",
			"    return (a + b - 1) / b;",
			"}",
			"",
			"string nc = \"NO\";",
			"string ns = \"No\";",
			"string yc = \"YES\";",
			"string ys = \"Yes\";",
			""
		],
		"description": "Leetcode boilerplate"
	}
}
