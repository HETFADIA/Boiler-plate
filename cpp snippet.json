{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"boilerplate": {
		"prefix": "boilerplate",
		"body": [
			"#pragma GCC optimize(\"O2\")",
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"using namespace std;",
			"using namespace chrono;",
			"using namespace __gnu_pbds;",
			"#define fastio                        \\",
			"    ios_base::sync_with_stdio(false); \\",
			"    cin.tie(NULL);",
			"#define endl \"\\n\"",
			"#define int long long",
			"#define lld long long",
			"#define p(x) cout << x << endl;",
			"#define p2(x, y) cout << x << \" \" << y << endl;",
			"#define p3(x, y, z) cout << x << \" \" << y << \" \" << z << endl;",
			"#define p4(x, y, z, a) cout << x << \" \" << y << \" \" << z << \" \" << a << endl;",
			"#define p5(x, y, z, a, b) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << endl;",
			"#define p6(x, y, z, a, b, c) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << \" \" << c << endl;",
			"#define p7(x, y, z, a, b, c, d) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << \" \" << c << \" \" << d << endl;",
			"#define p8(x, y, z, a, b, c, d, e) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << \" \" << c << \" \" << d << \" \" << e << endl;",
			"#define ps(x) cout << x << \" \";",
			"#define ps2(x, y) cout << x << \" \" << y << \" \";",
			"#define ps3(x, y, z) cout << x << \" \" << y << \" \" << z << \" \";",
			"#define ps4(x, y, z, a) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \";",
			"#define ps5(x, y, z, a, b) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << \" \";",
			"#define ps6(x, y, z, a, b, c) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << \" \" << c << \" \";",
			"#define ps7(x, y, z, a, b, c, d) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << \" \" << c << \" \" << d << \" \";",
			"#define ps8(x, y, z, a, b, c, d, e) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << \" \" << c << \" \" << d << \" \" << e << \" \";",
			"#define pns(x) cout << x;",
			"#define pns2(x, y) cout << x << y;",
			"#define pns3(x, y, z) cout << x << y << z;",
			"#define pns4(x, y, z, a) cout << x << y << z << a;",
			"#define setbits(x) __builtin_popcountll(x)",
			"#define msb(x) (64 - __builtin_clzll(x))",
			"#define rb(n) (n & (-n))",
			"#define rbm(n) (n & (n - 1))",
			"#define all(x) x.begin(), x.end()",
			"#define dll(x) x.begin(), x.end(), greater<lld>()",
			"#define vect(x, n) vector<lld> x(n, 0);",
			"#define vl vector<lld>",
			"#define umll unordered_map<lld, lld>",
			"#define usl unordered_set<lld>",
			"#define mll map<lld, lld>",
			"#define sorta(x) sort(all(x));",
			"#define sortd(x) sort(all(x), greater<lld>());",
			"#define matrix(x, n, m) vector<vector<lld>> x(n, vector<lld>(m, 0));",
			"#define matrixval(x, n, m, val) vector<vector<lld>> x(n, vector<lld>(m, val));",
			"#define matrixs(x, n, m, o) vector<vector<vector<lld>>> x(n, vector<vector<lld>>(m, vector<lld>(o, 0)));",
			"#define lcm(a, b) (a * b) / gcd(a, b)",
			"#define lb lower_bound",
			"#define ub upper_bound",
			"#define pb(x) push_back(x);",
			"#define pf(x) push_front(x);",
			"#define inf 1e18",
			"#define pll pair<lld, lld>",
			"#define ppll pair<pll, lld>",
			"#define ff first",
			"#define ss second",
			"#define inp(v)                         \\",
			"    for (lld i = 0; i < v.size(); i++) \\",
			"    {                                  \\",
			"        cin >> v[i];                   \\",
			"    }",
			"#define mod 1000000007",
			"template <typename T>",
			"using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"template <typename T, typename T2>",
			"using omap = tree<T, T2, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"template <typename T>",
			"using omulti_set = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"//member functions :",
			"//1. order_of_key(k) : number of elements strictly lesser than k",
			"//2. find_by_order(k) : k-th element in the set",
			"lld pow(lld x, lld y, lld p)",
			"{",
			"    lld res = 1; // Initialize result",
			"    x = x % p;",
			"    while (y > 0)",
			"    {",
			"        if (y & 1)",
			"            res = (res * x) % p;",
			"        y = y >> 1; // y = y/2",
			"        x = (x * x) % p;",
			"    }",
			"    return res;",
			"}",
			"lld pow(lld x, lld y)",
			"{",
			"    lld res = 1;",
			"    while (y > 0)",
			"    {",
			"        if (y & 1)",
			"            res = ((res) * (x));",
			"        y = y >> 1;",
			"        x = ((x) * (x));",
			"    }",
			"    return res;",
			"}",
			"lld ceil(lld a, lld n)",
			"{",
			"    return (a + n - 1) / n;",
			"}",
			"int gcd(int a, int b)",
			"{",
			"    if (b == 0)",
			"        return a;",
			"    a %= b;",
			"    return gcd(b, a);",
			"}",
			"void yn(lld a)",
			"{",
			"    cout << (a ? \"YES\" : \"NO\") << endl;",
			"}",
			"",
			"void fun()",
			"{",
			"}",
			"signed main()",
			"{",
			"    fastio;",
			"    auto start1 = high_resolution_clock::now();",
			"",
			"    lld t;",
			"    t = 1;",
			"    cin >> t;",
			"    while (t--)",
			"    {",
			"        fun();",
			"    }",
			"    auto stop1 = high_resolution_clock::now();",
			"    auto duration = duration_cast<microseconds>(stop1 - start1);",
			"#ifndef ONLINE_JUDGE",
			"    cerr << \"Time: \" << duration.count() / 1000.0 << endl;",
			"    cout << duration.count() / 1000.0 << endl;",
			"#endif",
			"}"
		],
		"description": "boilerplate"
	},
	"centroid": {
		"prefix": "centroid",
		"body": [
			"vector<int> Centroid(const vector<vector<int>> &g) {",
			"        int n = g.size();",
			"        vector<int> centroid;",
			"        vector<int> sz(n);",
			"        function<void (int, int)> dfs = [&](int u, int prev) {",
			"                sz[u] = 1;",
			"                bool is_centroid = true;",
			"                for (auto v : g[u]) if (v != prev) {",
			"                        dfs(v, u);",
			"                        sz[u] += sz[v];",
			"                        if (sz[v] > n / 2) is_centroid = false;",
			"                }",
			"                if (n - sz[u] > n / 2) is_centroid = false;",
			"                if (is_centroid) centroid.push_back(u);",
			"        };",
			"        dfs(0, -1);",
			"        return centroid;",
			"}"
		],
		"description": "centroid"
	},
	"sort by key=len": {
		"prefix": "size sorting",
		"body": [
			"// sorting according to the length int n;",
			"// cin >> n;",
			"// vector<string> a(n);",
			"// f(i, n)",
			"// {",
			"//     cin >> a[i];",
			"// }",
			"// sort(all(a), [&a](string x, string y)",
			"//      { return x.size() < y.size(); });",
			"// f(i, n)",
			"// {",
			"//     cout << a[i] << endl;",
			"// }"
		],
		"description": "sort by key=len"
	},
	"Trie": {
		"prefix": "Trie",
		"body": [
			"class Trie {",
			"public:",
			"    /** Initialize your data structure here. */",
			"    vector<vector<int>> t;",
			"    int N;",
			"    Trie() {",
			"        t = vector<vector<int>> (1, vector<int> (27));",
			"        N = 0;",
			"    }",
			"    ",
			"    /** Inserts a word into the trie. */",
			"    void insert(string word) {",
			"        int node = 0;",
			"        word.push_back('{');",
			"        for(auto ch: word){",
			"            if(!t[node][ch - 'a']){",
			"                t[node][ch - 'a'] = ++N;",
			"                t.push_back(vector<int>(27));",
			"            }",
			"            node = t[node][ch - 'a'];",
			"        }",
			"    }",
			"    ",
			"    /** Returns if the word is in the trie. */",
			"    bool search(string word) {",
			"        int node = 0;",
			"        int i = 0;",
			"        while(i < word.size() && t[node][word[i]-'a']){",
			"            node = t[node][word[i] - 'a'];",
			"            i += 1;",
			"        }",
			"        return i == word.size() && t[node][26] != 0;",
			"    }",
			"    ",
			"    /** Returns if there is any word in the trie that starts with the given prefix. */",
			"    bool startsWith(string word) {",
			"        int node = 0;",
			"        int i = 0;",
			"        while(i < word.size() && t[node][word[i]-'a']){",
			"            node = t[node][word[i] - 'a'];",
			"            i += 1;",
			"        }",
			"        return i == word.size();",
			"    }",
			"};"
		],
		"description": "Trie"
	},
	"disjoint set": {
		"prefix": "union find",
		"body": [
			"struct UnionFind {",
			" ",
			"    vector<int> par;",
			"    vector<int> sizes;",
			" ",
			"    UnionFind(int n)",
			"            : par(n), sizes(n, 1) {",
			"        for (int i = 0; i < n; i++) {",
			"            par[i] = i;",
			"        }",
			"    }",
			" ",
			"    int find(int x) {",
			"        return x == par[x] ? x : par[x] = find(par[x]);",
			"    }",
			" ",
			"    bool unite(int x, int y) {",
			"        x = find(x);",
			"        y = find(y);",
			"        if (x == y) return false;",
			"        if (sizes[x] < sizes[y]) swap(x, y);",
			"        par[y] = x;",
			"        sizes[x] += sizes[y];",
			"        return true;",
			"    }",
			" ",
			"    bool same(int x, int y) {",
			"        return find(x) == find(y);",
			"    }",
			" ",
			"    int get_size(int x) {",
			"        return sizes[find(x)];",
			"    }",
			" ",
			"    bool all_same() {",
			"        bool good = true;",
			"        for (int i = 0, n = par.size(); i < n; i++) if (find(0) != find(i)) good = false;",
			"        return good;",
			"    }",
			" ",
			"    int get_connectivity() {",
			"        set<int> s;",
			"        for (int i = 0, n = par.size(); i < n; i++) s.insert(find(i));",
			"        return s.size();",
			"    }",
			" ",
			"};"
		],
		"description": "disjoint set"
	},
	"bfs": {
		"prefix": "bfs",
		"body": [
			"void dfs(unordered_map<lld, set<lld>> &adj, unordered_map<lld, lld> &visited, lld v)",
			"{",
			"    visited[v] = 1;",
			"    p(v);",
			"    for (auto it = adj[v].begin(); it != adj[v].end(); it++)",
			"    {",
			"        if (visited[*it] == 0)",
			"        {",
			"            dfs(adj, visited, *it);",
			"        }",
			"    }",
			"}"
		],
		"description": "bfs"
	},
	"dfs": {
		"prefix": "dfs",
		"body": [
			"void dfs(unordered_map<lld, set<lld>> &adj, unordered_map<lld, lld> &visited, lld v)",
			"{",
			"    visited[v] = 1;",
			"    p(v);",
			"    for (auto it = adj[v].begin(); it != adj[v].end(); it++)",
			"    {",
			"        if (visited[*it] == 0)",
			"        {",
			"            dfs(adj, visited, *it);",
			"        }",
			"    }",
			"}"
		],
		"description": "dfs"
	},
	"inversion": {
		"prefix": "inversion",
		"body": [
			"lld inversion(vl &v)",
			"{",
			"    oset<pll> os;",
			"    lld inversioncount = 0;",
			"    lld counter = 0;",
			"    for (auto it = v.rbegin(); it != v.rend(); it++)",
			"    {",
			"        lld element = *it;",
			"        pll pair = {element, counter--};",
			"        os.insert(pair);",
			"        inversioncount += os.order_of_key(pair);",
			"    }",
			"    return inversioncount;",
			"}"
		],
		"description": "inversion"
	},
	"forward backward": {
		"prefix": "stack forward backward",
		"body": [
			"vl forward_array_not_equal(vl &v)",
			"{",
			"    // gives the next greater element index",
			"    // [100,100,100] gives 3 3 3 as output",
			"    lld n = v.size();",
			"    vl forward(n, n);",
			"    vl stack;",
			"    for (lld i = n - 1; i >= 0; i--)",
			"    {",
			"        while (stack.size() and v[stack.back()] <= v[i])",
			"        {",
			"            stack.pop_back();",
			"        }",
			"        if (stack.size() == 0)",
			"        {",
			"            forward[i] = n;",
			"        }",
			"        else",
			"        {",
			"            forward[i] = stack.back();",
			"        }",
			"        stack.push_back(i);",
			"    }",
			"    return forward;",
			"}",
			"vl backward_array_not_equal(vl &v)",
			"{",
			"    lld n = v.size();",
			"    vl backward(n);",
			"    vl stack;",
			"    for (lld i = 0; i < n; i++)",
			"    {",
			"        while (stack.size() and v[stack.back()] <= v[i])",
			"        {",
			"            stack.pop_back();",
			"        }",
			"        if (stack.size() == 0)",
			"        {",
			"            backward[i] = -1;",
			"        }",
			"        else",
			"        {",
			"            backward[i] = stack.back();",
			"        }",
			"        stack.push_back(i);",
			"    }",
			"    return backward;",
			"}"
		],
		"description": "forward backward"
	},
	"all factors": {
		"prefix": "factors",
		"body": [
			"vl all_factors(lld x)",
			"{",
			"    lld sqrta = sqrt(x);",
			"    vl v1;",
			"    vl v2;",
			"    for (lld i = 1; i <= sqrta; i++)",
			"    {",
			"        if (x % i == 0)",
			"        {",
			"            v1.pb(i);",
			"            lld j = x / i;",
			"            if (j != i)",
			"            {",
			"                v2.pb(x / i);",
			"            }",
			"        }",
			"    }",
			"    vl factors;",
			"    for (auto i : v1)",
			"    {",
			"        factors.pb(i);",
			"    }",
			"    for (auto i : reverse(v2))",
			"    {",
			"        factors.pb(i);",
			"    }",
			"    return factors;",
			"}"
		],
		"description": "all factors"
	},
	"spf": {
		"prefix": "spf",
		"body": [
			"const lld maxn = 2 * 1e7 + 1000;",
			"vl spf(2);",
			"",
			"void sieve()",
			"{",
			"    spf[1] = 1;",
			"    for (int i = 2; i < maxn; i++)",
			"",
			"        spf.pb(i);",
			"",
			"    for (int i = 4; i < maxn; i += 2)",
			"        spf[i] = 2;",
			"",
			"    for (int i = 3; i * i < maxn; i++)",
			"    {",
			"        if (spf[i] == i)",
			"        {",
			"            for (int j = i * i; j < maxn; j += i)",
			"                if (spf[j] == j)",
			"                    spf[j] = i;",
			"        }",
			"    }",
			"}",
			"",
			"vl primefactors(lld x)",
			"{",
			"    vl ret;",
			"    while (x != 1)",
			"    {",
			"        ret.pb(spf[x]);",
			"        x /= spf[x];",
			"    }",
			"    return ret;",
			"}"
		],
		"description": "spf"
	},
	"count prime sieve": {
		"prefix": "count prime sieve",
		"body": [
			"const lld a3 = 2 * 1e7 + 1000;",
			"bool prime[a3 + 1];",
			"lld primecount[a3 + 1];",
			"void SieveOfEratosthenes(lld n)",
			"{",
			"    memset(prime, true, sizeof(prime));",
			"    memset(primecount, 0, sizeof(primecount));",
			"    for (lld p = 2; p <= n; p++)",
			"    {",
			"        if (prime[p] == true)",
			"        {",
			"            primecount[p]++;",
			"            for (lld i = 2 * p; i <= n; i += p)",
			"            {",
			"                prime[i] = false;",
			"                primecount[i]++;",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "count prime sieve"
	},
	"Bellman ford": {
		"prefix": "bellman",
		"body": [
			"void bellman(lld n, vector<vector<pair<lld, lld>>> adj, vector<lld> &distance, lld &negative_cycle_found)",
			"{",
			"    lld s = n + 1;",
			"    //we run bellman ford from alpha=n+1;",
			"    lld relax_edge_modification = 0;",
			"    distance[s] = 0;",
			"    //distance of source is 0",
			"    vector<lld> times_pushed_in_queue(n + 2, 0);",
			"    vector<lld> count(n + 2, 0);",
			"    queue<lld> queue;",
			"    queue.push(s);",
			"    times_pushed_in_queue[s]++;",
			"    lld previous_element = s;",
			"    lld previous_relax_modification = 0;",
			"    lld element, adjacent, dista;",
			"    vector<pair<lld, lld>>::iterator i;",
			"    for (lld times = 1; times <= n + 1; times++)",
			"    {",
			"        //we will run the loop n+1 times as there are n vertices and one alpha;",
			"        previous_relax_modification = relax_edge_modification;",
			"        while (queue.empty() == 0)",
			"        {",
			"            element = queue.front();",
			"            if ((times_pushed_in_queue[element] - 1) / 2 > times)",
			"            {",
			"                //our next iteration must start so we break here;",
			"                break;",
			"            }",
			"            queue.pop();",
			"            times_pushed_in_queue[element]++;",
			"",
			"            for (i = adj[element].begin(); i != adj[element].end(); i++)",
			"            {",
			"                adjacent = i->second;",
			"                dista = i->first;",
			"                if (distance[adjacent] > dista + distance[element])",
			"                {",
			"                    distance[adjacent] = dista + distance[element];",
			"                    relax_edge_modification++;",
			"                    count[adjacent] = count[element] + 1;",
			"                    if (count[adjacent] > n - 1 + 1)",
			"                    {",
			"                        negative_cycle_found = 1;",
			"                        p(-1);",
			"                        return;",
			"                    }",
			"                    if (times_pushed_in_queue[adjacent] % 2 == 0)",
			"                    {",
			"                        queue.push(adjacent);",
			"                        times_pushed_in_queue[adjacent]++;",
			"                    }",
			"                }",
			"            }",
			"            previous_element = element;",
			"        }",
			"        if (times == n + 1)",
			"        {",
			"            if (previous_relax_modification < relax_edge_modification)",
			"            {",
			"                //if in the n+1th iteration we get relax edge modification then there is a negative cycle so we return;",
			"                p(-1);",
			"                return;",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "Bellman ford"
	},
	"Dijkshtra binary heap based": {
		"prefix": "Dijkshtra",
		"body": [
			"void change(vector<vector<pair<lld, lld>>> &adj_changed, vector<lld> distance)",
			"{",
			"    //used to find delta after running bellman ford;",
			"    for (lld i = 0; i < adj_changed.size(); i++)",
			"    {",
			"        for (lld j = 0; j < adj_changed[i].size(); j++)",
			"        {",
			"            if (adj_changed[i][j].first != inf)",
			"                adj_changed[i][j].first += distance[i] - distance[adj_changed[i][j].second];",
			"        }",
			"    }",
			"}",
			"void minimum_heapify(vector<pair<lld, lld>> &v, lld n, lld i, vector<lld> &address)",
			"{",
			"    //heapify the vector;",
			"    lld smallest = i;",
			"    lld left = 2 * smallest + 1;",
			"    lld right = 2 * smallest + 2;",
			"    lld a = left < n;",
			"    if (left < n && v[smallest] > v[left])",
			"    {",
			"        smallest = left;",
			"    }",
			"    lld b = right < n;",
			"    if (right < n && v[smallest] > v[right])",
			"    {",
			"        smallest = right;",
			"    }",
			"    lld go = smallest != i;",
			"    if (go)",
			"    {",
			"        //we swap the element if the parent is larger than any child",
			"        swap(v[i], v[smallest]);",
			"        //we also swap the address of them",
			"        swap(address[v[i].second], address[v[smallest].second]);",
			"        minimum_heapify(v, n, smallest, address);",
			"    }",
			"}",
			"lld parent(lld i)",
			"{",
			"    //returns parent;",
			"    return (i - 1) / 2;",
			"}",
			"void shift_up(vector<pair<lld, lld>> &v, lld n, lld i, vector<lld> &address)",
			"{",
			"    while (i > 0 && v[parent(i)] > v[i])",
			"    {",
			"        // Swap parent and current node",
			"        swap(v[parent(i)], v[i]);",
			"        swap(address[v[parent(i)].second], address[v[i].second]);",
			"        // Update i to parent of i",
			"        i = parent(i);",
			"    }",
			"}",
			"pair<lld, lld> get_min(vector<pair<lld, lld>> v)",
			"{",
			"    //the minimum element in heap is v[0]",
			"    return v[0];",
			"}",
			"void swaps(pair<lld, lld> &a, pair<lld, lld> &b)",
			"{",
			"    pair<lld, lld> e = a;",
			"    a = b;",
			"    b = e;",
			"}",
			"pair<lld, lld> extract_min(vector<pair<lld, lld>> &v, lld &size, vector<lld> &address)",
			"{",
			"    static pair<lld, lld> maxa = v[0];",
			"    swaps(v[0], v[size - 1]);",
			"    swap(address[v[0].second], address[v[size - 1].second]);",
			"    v[size - 1].first = inf;",
			"    size--;",
			"    minimum_heapify(v, size, 0, address);",
			"    return maxa;",
			"}",
			"void push_back(vector<pair<lld, lld>> &v, lld &size, pair<lld, lld> data, vector<lld> &address)",
			"{",
			"    address[data.second] = size;",
			"    v[size++] = data;",
			"    shift_up(v, size, size - 1, address);",
			"}",
			"void decrease_key(vector<pair<lld, lld>> &v, lld &size, lld n, pair<lld, lld> data, pair<lld, lld> new_data, vector<lld> &address)",
			"{",
			"    lld i = address[data.second];",
			"    v[i] = new_data;",
			"    shift_up(v, n, i, address);",
			"}",
			"lld empty(vector<pair<lld, lld>> v, lld n)",
			"{",
			"    if (v[0].first != inf)",
			"    {",
			"        return 0;",
			"    }",
			"    return 1;",
			"}",
			"void binary_heap_based_dijkstra(lld n, vector<vector<pair<lld, lld>>> adj, lld s, vector<lld> changed_distance)",
			"{",
			"    vector<pair<lld, lld>> v(n + 2);",
			"    lld size = 0;",
			"    lld size_of_arr = v.size();",
			"    vector<lld> address(n + 2);",
			"    for (lld i = 0; i < size_of_arr; i++)",
			"    {",
			"        if (i == s)",
			"        {",
			"            //if it is source we insert 0",
			"            pair<lld, lld> data = {0, s};",
			"            push_back(v, size, data, address);",
			"        }",
			"        else",
			"        {",
			"            //else if it is not source we insert all distances",
			"            pair<lld, lld> data = {inf, i};",
			"            push_back(v, size, data, address);",
			"        }",
			"    }",
			"    vector<lld> distance(n + 2, inf);",
			"    distance[s] = 0;",
			"    vector<lld> shortest_path_fount(n + 2, 0);",
			"    shortest_path_fount[s] = 1;",
			"    vector<lld> present(n + 2);",
			"    vector<pair<lld, lld>>::iterator i;",
			"    pair<lld, lld> top_element;",
			"    while (empty(v, n) == 0)",
			"    {",
			"        //get min returns the vertex having minimum wt in the form of {wt,vertex}",
			"        top_element = get_min(v);",
			"        lld element = top_element.second;",
			"        lld dist = top_element.first;",
			"        extract_min(v, size, address);",
			"        for (i = adj[element].begin(); i != adj[element].end(); i++)",
			"        {",
			"            lld adjacent = i->second;",
			"            lld dista = i->first;",
			"            if (shortest_path_fount[adjacent] == 0 && distance[element] != inf && distance[adjacent] > dista + distance[element])",
			"            {",
			"                decrease_key(v, size, n + 2, {distance[adjacent], adjacent}, {dista + distance[element], adjacent}, address);",
			"                distance[adjacent] = dista + distance[element];",
			"            }",
			"        }",
			"        shortest_path_fount[element] = 1;",
			"    }",
			"    for (lld i = 1; i < n + 1; i++)",
			"    {",
			"        if (same(i, s))",
			"        {",
			"            ps(0);",
			"        }",
			"        else if (same(distance[i], inf))",
			"        {",
			"            ps(inf);",
			"        }",
			"        else",
			"        {",
			"            lld corrected = distance[i] - changed_distance[s] + changed_distance[i];",
			"            ps(corrected);",
			"        }",
			"    }",
			"    p(\"\");",
			"}"
		],
		"description": "Dijkshtra binary heap based"
	},
	"sieve of eratosthenes": {
		"prefix": "sieve",
		"body": [
			"const lld a3 = 1000000;",
			"bool prime[a3 + 1];",
			"void SieveOfEratosthenes(int n)",
			"{",
			"",
			"    memset(prime, true, sizeof(prime));",
			"",
			"    for (int p = 2; p * p <= n; p++)",
			"    {",
			"        if (prime[p] == true)",
			"        {",
			"",
			"            for (int i = p * p; i <= n; i += p)",
			"                prime[i] = false;",
			"        }",
			"    }",
			"}"
		],
		"description": "sieve of eratosthenes"
	},
	"Leetcode boilerplate": {
		"prefix": "Leetcode",
		"body": [
			"#pragma GCC optimize(\"O2\")",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using namespace chrono;",
			"#define fastio                        \\",
			"    ios_base::sync_with_stdio(false); \\",
			"    cin.tie(NULL);                    \\",
			"    cout.tie(NULL);",
			"#define int long long",
			"#define lld long long",
			"#define tr(i, x) for (auto i : x)",
			"#define p(x) cout << x << endl;",
			"#define p2(x, y) cout << x << \" \" << y << endl;",
			"#define p3(x, y, z) cout << x << \" \" << y << \" \" << z << endl;",
			"#define p4(x, y, z, a) cout << x << \" \" << y << \" \" << z << \" \" << a << endl;",
			"#define p5(x, y, z, a, b) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << endl;",
			"#define ps(x) cout << x << \" \";",
			"#define ps2(x, y) cout << x << \" \" << y << \" \";",
			"#define ps3(x, y, z) cout << x << \" \" << y << \" \" << z << \" \";",
			"#define ps4(x, y, z, a) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \";",
			"#define ps5(x, y, z, a, b) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << \" \";",
			"#define pns(x) cout << x;",
			"#define endl \"\\n\"",
			"#define all(x) x.begin(), x.end()",
			"#define dll(x) x.begin(), x.end(), greater<lld>()",
			"#define vect(x, n) vector<lld> x(n, 0);",
			"#define matrix(x, n, m) vector<vector<lld>> x(n, vector<lld>(m, 0));",
			"#define gcd(a, b) __gcd(a, b)",
			"#define lcm(a, b) (a * b) / gcd(a, b)",
			"#define lb lower_bound",
			"#define ub upper_bound",
			"#define pb(x) push_back(x);",
			"#define pf(x) push_front(x);",
			"#define mkp(x, y) make_pair(x, y)",
			"#define f(i, a, b) for (lld i = (a); i < (b); i++)",
			"#define fr(i, a, b) for (lld i = (b); i > a; i--)",
			"#define inf 999999999999999",
			"#define pll pair<lld, lld>",
			"#define ppll pair<pll, lld>",
			"#define ff first",
			"#define ss second",
			"#define mod 1000000007",
			"void addedge(unordered_map<lld, set<lld>> &adj, lld u, lld v)",
			"{",
			"    adj[u].insert(v);",
			"    adj[v].insert(u);",
			"}",
			"void dfs(unordered_map<lld, set<lld>> &adj, unordered_map<lld, lld> visited, lld v)",
			"{",
			"    visited[v] = 1;",
			"    p(v);",
			"    for (auto it = adj[v].begin(); it != adj[v].end(); it++)",
			"    {",
			"        if (visited[*it] == 0)",
			"        {",
			"            dfs(adj, visited, *it);",
			"        }",
			"    }",
			"}",
			"void bfs(unordered_map<lld, set<lld>> &adj, unordered_map<lld, lld> visited, lld v)",
			"{",
			"    visited[v] = 1;",
			"    queue<lld> q;",
			"    q.push(v);",
			"    while (q.empty() == 0)",
			"    {",
			"        lld s = q.front();",
			"        // p(s);",
			"        q.pop();",
			"",
			"        for (auto it = adj[s].begin(); it != adj[s].end(); it++)",
			"        {",
			"            if (visited[*it] == 0)",
			"            {",
			"                q.push(*it);",
			"                visited[*it] = 1;",
			"            }",
			"        }",
			"    }",
			"}",
			"struct cmpfunc",
			"{",
			"    bool operator()(const long &a, const long &b) const",
			"    {",
			"        return a > b;",
			"    }",
			"};",
			"lld pow(lld x, lld y, lld p)",
			"{",
			"    lld res = 1; // Initialize result",
			"",
			"    // Update x if it is more than or",
			"    // equal to p",
			"    x = x % p;",
			"",
			"    while (y > 0)",
			"    {",
			"        // If y is odd, multiply x with the result",
			"        if (y & 1)",
			"            res = (res * x) % p;",
			"",
			"        // y must be even now",
			"        y = y >> 1; // y = y/2",
			"        x = (x * x) % p;",
			"    }",
			"    return res;",
			"}",
			"lld pow(lld x, lld y)",
			"{",
			"    lld res = 1;",
			"    while (y > 0)",
			"    {",
			"        if (y & 1)",
			"            res = ((res) * (x));",
			"        y = y >> 1;",
			"        x = ((x) * (x));",
			"    }",
			"    return res;",
			"}",
			"lld bintodec(lld n)",
			"{",
			"    lld num = n;",
			"    lld dec_value = 0;",
			"",
			"    // Initializing base value to 1, i.e 2^0",
			"    lld base = 1;",
			"",
			"    lld temp = num;",
			"    while (temp)",
			"    {",
			"        lld last_digit = temp % 10;",
			"        temp = temp / 10;",
			"",
			"        dec_value += last_digit * base;",
			"",
			"        base = base * 2;",
			"    }",
			"",
			"    return dec_value;",
			"}",
			"string dectobin(lld n)",
			"{",
			"",
			"    //finding the binary form of the number and",
			"    //coneverting it to string.",
			"    string s = bitset<64>(n).to_string();",
			"",
			"    //Finding the first occurance of \"1\"",
			"    //to strip off the leading zeroes.",
			"    const auto loc1 = s.find('1');",
			"",
			"    if (loc1 != string::npos)",
			"        return s.substr(loc1);",
			"",
			"    return \"0\";",
			"}",
			"void print(vector<lld> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cout << v[i] << \" \";",
			"    }",
			"    cout << endl;",
			"}",
			"void print(vector<string> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cout << v[i] << \" \";",
			"    }",
			"    cout << endl;",
			"}",
			"void print(vector<pll> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cout << v[i].first << \" \" << v[i].second << \" \";",
			"    }",
			"    cout << endl;",
			"}",
			"void prints(vector<int> &v)",
			"{",
			"    //prints the vector from 1st index",
			"    for (int i = 1; i != v.size(); i++)",
			"    {",
			"        ps(v[i]);",
			"    }",
			"}",
			"void print(set<pair<int, int>> &seta)",
			"{",
			"    //prints the set it is used for debuggging",
			"    set<pair<int, int>>::iterator i;",
			"    for (i = seta.begin(); i != seta.end(); i++)",
			"    {",
			"        ps2(i->first, i->second);",
			"    }",
			"    p(\"\");",
			"}",
			"void print(map<int, int> &mapa)",
			"{",
			"    //prints the map it is used for debuggging",
			"    map<int, int>::iterator i;",
			"    for (i = mapa.begin(); i != mapa.end(); i++)",
			"    {",
			"        ps4(\"{\", i->first, i->second, \"}\");",
			"    }",
			"    p(\"\");",
			"}",
			"void print(set<int> &seta)",
			"{",
			"    //prints the set it is used for debuggging",
			"",
			"    for (auto i = seta.begin(); i != seta.end(); i++)",
			"    {",
			"        ps(*i);",
			"    }",
			"    p(\"\");",
			"}",
			"void print(map<pair<int, int>, pair<int, int>> &mapa)",
			"{",
			"    //prints the map it is used for debuggging",
			"    map<pair<int, int>, pair<int, int>>::iterator i;",
			"    for (i = mapa.begin(); i != mapa.end(); i++)",
			"    {",
			"        ps4(i->first.first, i->first.second, i->second.first, i->second.second);",
			"    }",
			"}",
			"void print(map<pair<int, int>, int> &mapa)",
			"{",
			"    //prints the map it is used for debuggging",
			"    map<pair<int, int>, int>::iterator i;",
			"    for (i = mapa.begin(); i != mapa.end(); i++)",
			"    {",
			"        ps5(\"{\", i->first.first, i->first.second, i->second, \"}\");",
			"    }",
			"    p(\"\");",
			"}",
			"void print(pair<int, int> &tuple)",
			"{",
			"    //prints the tuple it is used for debuggging",
			"    p2(tuple.first, tuple.second);",
			"}",
			"void print(set<lld, greater<lld>> &s)",
			"{",
			"    for (auto i = s.begin(); i != s.end(); i++)",
			"    {",
			"        p(*i);",
			"    }",
			"}",
			"int min_index(vector<int> &cost)",
			"{",
			"    //returns the index of the min element of cost ie if min(cost)=4 then it returns index(4) in cost vector",
			"    int index = 0;",
			"    int min_cost = 0;",
			"    if (cost.size())",
			"    {",
			"        min_cost = cost[0];",
			"    }",
			"    for (int i = 0; i < cost.size(); i++)",
			"    {",
			"        if (min_cost > cost[i])",
			"        {",
			"            min_cost = cost[i];",
			"            index = i;",
			"        }",
			"    }",
			"    return index;",
			"}",
			"// const lld a3=1000000;",
			"// bool prime[a3 + 1];",
			"// void SieveOfEratosthenes(int n)",
			"// {",
			"",
			"//     memset(prime, true, sizeof(prime));",
			"",
			"//     for (int p = 2; p * p <= n; p++)",
			"//     {",
			"//         if (prime[p] == true)",
			"//         {",
			"",
			"//             for (int i = p * p; i <= n; i += p)",
			"//                 prime[i] = false;",
			"//         }",
			"//     }",
			"// }",
			"void Counter(vector<lld> &v, unordered_map<lld, lld> &um)",
			"{",
			"    for (int i : v)",
			"    {",
			"        um[i] += 1;",
			"    }",
			"}",
			"unordered_map<lld, lld> Counter(vector<lld> &v)",
			"{",
			"    unordered_map<lld, lld> um;",
			"    for (int i : v)",
			"    {",
			"        um[i] += 1;",
			"    }",
			"    return um;",
			"}",
			"unordered_map<char, lld> Counter(string &a)",
			"{",
			"    unordered_map<char, lld> um;",
			"    for (char i : a)",
			"    {",
			"        um[i] += 1;",
			"    }",
			"    return um;",
			"}",
			"void get_list(vector<lld> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cin >> v[i];",
			"    }",
			"}",
			"vector<lld> sliced(vector<lld> &v, lld start, lld end)",
			"{",
			"    vector<lld> another;",
			"    f(i, start, end)",
			"    {",
			"        another.pb(v[i]);",
			"    }",
			"    return another;",
			"}",
			"vector<lld> sliced(vector<lld> &v, lld start)",
			"{",
			"    vector<lld> another;",
			"    f(i, start, v.size())",
			"    {",
			"        another.pb(v[i]);",
			"    }",
			"    return another;",
			"}",
			"void ignore(lld a)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p(a);",
			"#endif",
			"}",
			"void ignore(lld a, lld b)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p2(a, b);",
			"#endif",
			"}",
			"void ignore(lld a, lld b, lld c)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p3(a, b, c);",
			"#endif",
			"}",
			"void ignore(lld a, lld b, lld c, lld d)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p4(a, b, c, d);",
			"#endif",
			"}",
			"void ignore(lld a, lld b, lld c, lld d, lld e)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p5(a, b, c, d, e);",
			"#endif",
			"}",
			"lld kth_no_not_divisible_by_n(lld n, lld k)",
			"{",
			"    return k + (k - 1) / (n - 1);",
			"}",
			"lld ceil(lld a, lld b)",
			"{",
			"    return (a + b - 1) / b;",
			"}",
			"",
			"string nc = \"NO\";",
			"string ns = \"No\";",
			"string yc = \"YES\";",
			"string ys = \"Yes\";",
			""
		],
		"description": "Leetcode boilerplate"
	},
	"google": {
		"prefix": "kickstart",
		"body": [
			"#pragma GCC optimize(\"O2\")",
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"using namespace std;",
			"using namespace chrono;",
			"using namespace __gnu_pbds;",
			"#define fastio                        \\",
			"    ios_base::sync_with_stdio(false); \\",
			"    cin.tie(NULL);",
			"#define endl \"\\n\"",
			"#define int long long",
			"#define lld long long",
			"#define p(x) cout << x << endl;",
			"#define p2(x, y) cout << x << \" \" << y << endl;",
			"#define p3(x, y, z) cout << x << \" \" << y << \" \" << z << endl;",
			"#define p4(x, y, z, a) cout << x << \" \" << y << \" \" << z << \" \" << a << endl;",
			"#define p5(x, y, z, a, b) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << endl;",
			"#define p6(x, y, z, a, b, c) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << \" \" << c << endl;",
			"#define p7(x, y, z, a, b, c, d) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << \" \" << c << \" \" << d << endl;",
			"#define p8(x, y, z, a, b, c, d, e) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << \" \" << c << \" \" << d << \" \" << e << endl;",
			"#define ps(x) cout << x << \" \";",
			"#define ps2(x, y) cout << x << \" \" << y << \" \";",
			"#define ps3(x, y, z) cout << x << \" \" << y << \" \" << z << \" \";",
			"#define ps4(x, y, z, a) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \";",
			"#define ps5(x, y, z, a, b) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << \" \";",
			"#define ps6(x, y, z, a, b, c) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << \" \" << c << \" \";",
			"#define ps7(x, y, z, a, b, c, d) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << \" \" << c << \" \" << d << \" \";",
			"#define ps8(x, y, z, a, b, c, d, e) cout << x << \" \" << y << \" \" << z << \" \" << a << \" \" << b << \" \" << c << \" \" << d << \" \" << e << \" \";",
			"#define pns(x) cout << x;",
			"#define pns2(x, y) cout << x << y;",
			"#define pns3(x, y, z) cout << x << y << z;",
			"#define pns4(x, y, z, a) cout << x << y << z << a;",
			"#define pns5(x, y, z, a, b) cout << x << y << z << a << b;",
			"#define pns6(x, y, z, a, b, c) cout << x << y << z << a << b << c;",
			"#define pns7(x, y, z, a, b, c, d) cout << x << y << z << a << b << c << d;",
			"#define pns8(x, y, z, a, b, c, d, e) cout << x << y << z << a << b << c << d << e;",
			"#define setbits(x) __builtin_popcountll(x)",
			"#define msb(x) (64 - __builtin_clzll(x))",
			"#define rb(n) (n & (-n))",
			"#define rbm(n) (n & (n - 1))",
			"#define all(x) x.begin(), x.end()",
			"#define dll(x) x.begin(), x.end(), greater<lld>()",
			"#define vect(x, n) vector<lld> x(n, 0);",
			"#define vl vector<lld>",
			"#define matrix(x, n, m) vector<vector<lld>> x(n, vector<lld>(m, 0));",
			"#define matrixval(x, n, m, val) vector<vector<lld>> x(n, vector<lld>(m, val));",
			"#define matrixs(x, n, m, o) vector<vector<vector<lld>>> x(n, vector<vector<lld>>(m, vector<lld>(o, 0)));",
			"#define gcd(a, b) __gcd(a, b)",
			"#define lcm(a, b) (a * b) / gcd(a, b)",
			"#define lb lower_bound",
			"#define ub upper_bound",
			"#define pb(x) push_back(x);",
			"#define pf(x) push_front(x);",
			"#define mkp(x, y) make_pair(x, y)",
			"#define f(i, a, b) for (lld i = (a); i < (b); i++)",
			"#define fr(i, a, b) for (lld i = (b); i > a; i--)",
			"#define inf LLONG_MAX",
			"#define pll pair<lld, lld>",
			"#define ppll pair<pll, lld>",
			"#define ff first",
			"#define ss second",
			"#define inp(v)                         \\",
			"    for (lld i = 0; i < v.size(); i++) \\",
			"    {                                  \\",
			"        cin >> v[i];                   \\",
			"    }",
			"#define MOD 1000000007",
			"#define mod 1000000007",
			"typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;",
			"//member functions :",
			"//1. order_of_key(k) : number of elements strictly lesser than k",
			"//2. find_by_order(k) : k-th element in the set",
			"void addedge(unordered_map<lld, set<lld>> &adj, lld u, lld v)",
			"{",
			"    adj[u].insert(v);",
			"    adj[v].insert(u);",
			"}",
			"void dfs(unordered_map<lld, set<lld>> &adj, unordered_map<lld, lld> &visited, lld v)",
			"{",
			"    visited[v] = 1;",
			"    p(v);",
			"    for (auto it = adj[v].begin(); it != adj[v].end(); it++)",
			"    {",
			"        if (visited[*it] == 0)",
			"        {",
			"            dfs(adj, visited, *it);",
			"        }",
			"    }",
			"}",
			"void bfs(unordered_map<lld, set<lld>> &adj, unordered_map<lld, lld> visited, lld v)",
			"{",
			"    visited[v] = 1;",
			"    queue<lld> q;",
			"    q.push(v);",
			"    while (q.empty() == 0)",
			"    {",
			"        lld s = q.front();",
			"        // p(s);",
			"        q.pop();",
			"",
			"        for (auto it = adj[s].begin(); it != adj[s].end(); it++)",
			"        {",
			"            if (visited[*it] == 0)",
			"            {",
			"                q.push(*it);",
			"                visited[*it] = 1;",
			"            }",
			"        }",
			"    }",
			"}",
			"struct cmpfunc",
			"{",
			"    bool operator()(const long &a, const long &b) const",
			"    {",
			"        return a > b;",
			"    }",
			"};",
			"typedef struct node",
			"{",
			"    int val;",
			"    struct node *left;",
			"    struct node *right;",
			"}(node);",
			"void print(node *newnode)",
			"{",
			"    if (newnode)",
			"    {",
			"        p(newnode->val);",
			"        print(newnode->left);",
			"        print(newnode->right);",
			"    }",
			"}",
			"node *get_newnode()",
			"{",
			"    node *newnode = new node;",
			"    newnode->val = 0;",
			"    newnode->left = NULL;",
			"    newnode->right = NULL;",
			"    return newnode;",
			"}",
			"lld pow(lld x, lld y, lld p)",
			"{",
			"    lld res = 1; // Initialize result",
			"",
			"    // Update x if it is more than or",
			"    // equal to p",
			"    x = x % p;",
			"",
			"    while (y > 0)",
			"    {",
			"        // If y is odd, multiply x with the result",
			"        if (y & 1)",
			"            res = (res * x) % p;",
			"",
			"        // y must be even now",
			"        y = y >> 1; // y = y/2",
			"        x = (x * x) % p;",
			"    }",
			"    return res;",
			"}",
			"lld pow(lld x, lld y)",
			"{",
			"    lld res = 1;",
			"    while (y > 0)",
			"    {",
			"        if (y & 1)",
			"            res = ((res) * (x));",
			"        y = y >> 1;",
			"        x = ((x) * (x));",
			"    }",
			"    return res;",
			"}",
			"string bin(lld n)",
			"{",
			"    // similar to bin(a)[2:] in python",
			"    string answer = \"\";",
			"    while (n)",
			"    {",
			"        if (n % 2 == 1)",
			"        {",
			"            answer += '1';",
			"        }",
			"        else",
			"        {",
			"            answer += '0';",
			"        }",
			"        n /= 2;",
			"    }",
			"    reverse(all(answer));",
			"    return answer;",
			"}",
			"lld bintodec(lld n)",
			"{",
			"    lld num = n;",
			"    lld dec_value = 0;",
			"",
			"    // Initializing base value to 1, i.e 2^0",
			"    lld base = 1;",
			"",
			"    lld temp = num;",
			"    while (temp)",
			"    {",
			"        lld last_digit = temp % 10;",
			"        temp = temp / 10;",
			"",
			"        dec_value += last_digit * base;",
			"",
			"        base = base * 2;",
			"    }",
			"",
			"    return dec_value;",
			"}",
			"string dectobin(lld n)",
			"{",
			"",
			"    //finding the binary form of the number and",
			"    //coneverting it to string.",
			"    string s = bitset<64>(n).to_string();",
			"",
			"    //Finding the first occurance of \"1\"",
			"    //to strip off the leading zeroes.",
			"    const auto loc1 = s.find('1');",
			"",
			"    if (loc1 != string::npos)",
			"        return s.substr(loc1);",
			"",
			"    return \"0\";",
			"}",
			"string binary32bit(lld n)",
			"{",
			"    string s = bitset<32>(n).to_string();",
			"    return s;",
			"}",
			"string binary64bit(lld n)",
			"{",
			"    string s = bitset<64>(n).to_string();",
			"    return s;",
			"}",
			"void print(vector<lld> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cout << v[i] << \" \";",
			"    }",
			"    cout << endl;",
			"}",
			"void print(vector<vector<lld>> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        for (lld j = 0; j < v[i].size(); j++)",
			"        {",
			"            ps(v[i][j]);",
			"        }",
			"        p(\"\");",
			"    }",
			"}",
			"void print(vector<string> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cout << v[i] << \" \";",
			"    }",
			"    cout << endl;",
			"}",
			"void print(vector<pll> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cout << v[i].first << \" \" << v[i].second << \" \";",
			"    }",
			"    cout << endl;",
			"}",
			"void prints(vector<int> &v)",
			"{",
			"    //prints the vector from 1st index",
			"    for (int i = 1; i != v.size(); i++)",
			"    {",
			"        ps(v[i]);",
			"    }",
			"}",
			"void print(set<pair<int, int>> &seta)",
			"{",
			"    //prints the set it is used for debuggging",
			"    set<pair<int, int>>::iterator i;",
			"    for (i = seta.begin(); i != seta.end(); i++)",
			"    {",
			"        ps2(i->first, i->second);",
			"    }",
			"    p(\"\");",
			"}",
			"void print(map<int, int> &mapa)",
			"{",
			"    //prints the map it is used for debuggging",
			"    map<int, int>::iterator i;",
			"    for (i = mapa.begin(); i != mapa.end(); i++)",
			"    {",
			"        ps4(\"{\", i->first, i->second, \"}\");",
			"    }",
			"    p(\"\");",
			"}",
			"void print(set<int> &seta)",
			"{",
			"    //prints the set it is used for debuggging",
			"    set<int>::iterator i;",
			"    for (i = seta.begin(); i != seta.end(); i++)",
			"    {",
			"        ps(*i);",
			"    }",
			"    p(\"\");",
			"}",
			"void print(map<pair<int, int>, pair<int, int>> &mapa)",
			"{",
			"    //prints the map it is used for debuggging",
			"    map<pair<int, int>, pair<int, int>>::iterator i;",
			"    for (i = mapa.begin(); i != mapa.end(); i++)",
			"    {",
			"        ps4(i->first.first, i->first.second, i->second.first, i->second.second);",
			"    }",
			"}",
			"void print(map<pair<int, int>, int> &mapa)",
			"{",
			"    //prints the map it is used for debuggging",
			"    map<pair<int, int>, int>::iterator i;",
			"    for (i = mapa.begin(); i != mapa.end(); i++)",
			"    {",
			"        ps5(\"{\", i->first.first, i->first.second, i->second, \"}\");",
			"    }",
			"    p(\"\");",
			"}",
			"void print(pair<int, int> &tuple)",
			"{",
			"    //prints the tuple it is used for debuggging",
			"    p2(tuple.first, tuple.second);",
			"}",
			"void print(set<lld, greater<lld>> &s)",
			"{",
			"    for (auto i = s.begin(); i != s.end(); i++)",
			"    {",
			"        p(*i);",
			"    }",
			"}",
			"",
			"int min_index(vector<int> &cost)",
			"{",
			"    //returns the index of the min element of cost ie if min(cost)=4 then it returns index(4) in cost vector",
			"    int index = 0;",
			"    int min_cost = 0;",
			"    if (cost.size())",
			"    {",
			"        min_cost = cost[0];",
			"    }",
			"    for (int i = 0; i < cost.size(); i++)",
			"    {",
			"        if (min_cost > cost[i])",
			"        {",
			"            min_cost = cost[i];",
			"            index = i;",
			"        }",
			"    }",
			"    return index;",
			"}",
			"// const lld a3=1000000;",
			"// bool prime[a3 + 1];",
			"// void SieveOfEratosthenes(int n)",
			"// {",
			"",
			"//     memset(prime, true, sizeof(prime));",
			"",
			"//     for (int p = 2; p * p <= n; p++)",
			"//     {",
			"//         if (prime[p] == true)",
			"//         {",
			"",
			"//             for (int i = p * p; i <= n; i += p)",
			"//                 prime[i] = false;",
			"//         }",
			"//     }",
			"// }",
			"vector<lld> SieveOfEratosthenes(lld n)",
			"{",
			"    vector<lld> prime(n + 10);",
			"    for (int p = 2; p * p <= n; p++)",
			"    {",
			"        if (prime[p] == true)",
			"        {",
			"",
			"            for (int i = p * p; i <= n; i += p)",
			"                prime[i] = false;",
			"        }",
			"    }",
			"    return prime;",
			"}",
			"void Counter(vector<lld> &v, unordered_map<lld, lld> &um)",
			"{",
			"    for (int i : v)",
			"    {",
			"        um[i] += 1;",
			"    }",
			"}",
			"unordered_map<lld, lld> Counter(vector<lld> &v)",
			"{",
			"    unordered_map<lld, lld> um;",
			"    for (int i : v)",
			"    {",
			"        um[i] += 1;",
			"    }",
			"    return um;",
			"}",
			"unordered_map<char, lld> Counter(string &a)",
			"{",
			"    unordered_map<char, lld> um;",
			"    for (char i : a)",
			"    {",
			"        um[i] += 1;",
			"    }",
			"    return um;",
			"}",
			"void get_list(vector<lld> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cin >> v[i];",
			"    }",
			"}",
			"vector<lld> sliced(vector<lld> &v, lld start, lld end)",
			"{",
			"    vector<lld> another;",
			"    f(i, start, end)",
			"    {",
			"        another.pb(v[i]);",
			"    }",
			"    return another;",
			"}",
			"vector<lld> sliced(vector<lld> &v, lld start)",
			"{",
			"    vector<lld> another;",
			"    f(i, start, v.size())",
			"    {",
			"        another.pb(v[i]);",
			"    }",
			"    return another;",
			"}",
			"void ignore(lld a)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p(a);",
			"#endif",
			"}",
			"void ignore2(lld a, lld b)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p2(a, b);",
			"#endif",
			"}",
			"void ignore3(lld a, lld b, lld c)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p3(a, b, c);",
			"#endif",
			"}",
			"void ignore4(lld a, lld b, lld c, lld d)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p4(a, b, c, d);",
			"#endif",
			"}",
			"void ignore5(lld a, lld b, lld c, lld d, lld e)",
			"{",
			"#ifndef ONLINE_JUDGE",
			"    p5(a, b, c, d, e);",
			"#endif",
			"}",
			"lld kth_no_not_divisible_by_n(lld n, lld k)",
			"{",
			"    return k + (k - 1) / (n - 1);",
			"}",
			"lld ceil(lld a, lld n)",
			"{",
			"",
			"    return (a + n - 1) / n;",
			"}",
			"lld get_mod(lld a, lld b)",
			"{",
			"    lld answer = a % b;",
			"    if (answer < 0)",
			"    {",
			"        return answer + b;",
			"    }",
			"    return answer;",
			"}",
			"",
			"string nc = \"NO\";",
			"string ns = \"No\";",
			"string yc = \"YES\";",
			"string ys = \"Yes\";",
			"",
			"void yesno(lld a)",
			"{",
			"    if (a)",
			"    {",
			"        p(yc);",
			"    }",
			"    else",
			"    {",
			"        p(nc);",
			"    }",
			"}",
			"",
			"void reduce(map<lld, lld> &m, lld value)",
			"{",
			"    if (m[value] <= 1)",
			"    {",
			"        m.erase(value);",
			"    }",
			"    else",
			"    {",
			"        m[value]--;",
			"    }",
			"}",
			"lld present(map<lld, lld> &m, lld value)",
			"{",
			"    return m.find(value) != m.end();",
			"}",
			"lld issq(lld n)",
			"{",
			"    lld sqrta = sqrt(n);",
			"    return sqrta * sqrta == n;",
			"}",
			"lld issq(double n)",
			"{",
			"    lld sqrta = sqrt(n);",
			"    return sqrta * sqrta == n;",
			"}",
			"",
			"void fun()",
			"{",
			"}",
			"signed main()",
			"{",
			"    fastio;",
			"    auto start1 = high_resolution_clock::now();",
			"",
			"    lld t;",
			"    t = 1;",
			"    cin >> t;",
			"",
			"    lld count = 1;",
			"",
			"    while (t--)",
			"    {",
			"        pns3(\"Case #\", count++, \": \");",
			"",
			"        fun();",
			"    }",
			"",
			"    auto stop1 = high_resolution_clock::now();",
			"    auto duration = duration_cast<microseconds>(stop1 - start1);",
			"#ifndef ONLINE_JUDGE",
			"    // cerr << \"Time: \" << duration.count() / 1000.0 << endl;",
			"    // cout << duration.count() / 1000.0 << endl;",
			"#endif",
			"}"
		],
		"description": "google"
	},
	"sparcetable range query": {
		"prefix": "sparcetable range query",
		"body": [
			"template <typename Node>",
			"struct SparseTable",
			"{",
			"    vector<vector<Node>> table;",
			"    vector<int> logValues;",
			"    int n;",
			"    int maxLog;",
			"    vector<int> a;",
			"    SparseTable(vector<int> &arr)",
			"    {",
			"        n = arr.size();",
			"        a = arr;",
			"        table.resize(n);",
			"        logValues.resize(n + 1);",
			"        maxLog = msb(n);",
			"        for (int i = 2; i <= n; i++)",
			"        {",
			"            logValues[i] = logValues[i / 2] + 1;",
			"        }",
			"        for (int i = 0; i < n; i++)",
			"        {",
			"            table[i].resize(maxLog + 1);",
			"            fill(table[i].begin(), table[i].end(), Node());",
			"        }",
			"        build();",
			"    }",
			"    void build()",
			"    {",
			"        for (int i = 0; i < n; i++)",
			"        {",
			"            table[i][0] = Node(a[i]);",
			"        }",
			"        for (int i = 1; i <= maxLog; i++)",
			"        {",
			"            for (int j = 0; (j + (1 << i)) <= n; j++)",
			"            {",
			"                table[j][i].merge(table[j][i - 1], table[j + (1 << (i - 1))][i - 1]);",
			"            }",
			"        }",
			"    }",
			"    Node queryNormal(int left, int right)",
			"    {",
			"        //gives node form [left,right) just like pyrival",
			"        Node ans = Node();",
			"        for (int j = logValues[right - left]; j >= 0; j--)",
			"        {",
			"            if ((1 << j) <= right - left)",
			"            {",
			"                ans.merge(ans, table[left][j]);",
			"                left += (1 << j);",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"    Node query(int left, int right)",
			"    {",
			"        //gives node from [left,right) just like pyrival",
			"        int j = logValues[right - left];",
			"        Node ans = Node();",
			"        ans.merge(table[left][j], table[right - (1 << j)][j]);",
			"        return ans;",
			"    }",
			"};",
			"struct Node1",
			"{",
			"    int val;",
			"    Node1()",
			"    {",
			"        val = 0;",
			"    }",
			"    Node1(int v)",
			"    {",
			"        val = v;",
			"    }",
			"    void merge(Node1 &l, Node1 &r)",
			"    {",
			"        val = gcd(l.val, r.val);",
			"    }",
			"};"
		],
		"description": "sparcetable range query"
	},
	"primeFactors brute force": {
		"prefix": "primeFactors brute force",
		"body": [
			"lld primeFactors(int n)",
			"{",
			"    lld count = 0;",
			"    while (n % 2 == 0)",
			"    {",
			"        // v1.pb(2);",
			"        count += 1;",
			"        n = n / 2;",
			"    }",
			"",
			"    // n must be odd at this point. So we can skip",
			"    // one element (Note i = i +2)",
			"    for (int i = 3; i <= sqrt(n); i = i + 2)",
			"    {",
			"        // While i divides n, print i and divide n",
			"        while (n % i == 0)",
			"        {",
			"            // v1.pb(i);",
			"            count += 1;",
			"            n = n / i;",
			"        }",
			"    }",
			"    if (n > 2)",
			"    {",
			"",
			"        // v1.pb(n);",
			"        count += 1;",
			"    }",
			"    return count;",
			"}"
		],
		"description": "primeFactors brute force"
	},
	"bin": {
		"prefix": "bin",
		"body": [
			"string bin(lld n)",
			"{",
			"    // similar to bin(a)[2:] in python",
			"    string answer = \"\";",
			"    while (n)",
			"    {",
			"        if (n % 2 == 1)",
			"        {",
			"            answer += '1';",
			"        }",
			"        else",
			"        {",
			"            answer += '0';",
			"        }",
			"        n /= 2;",
			"    }",
			"    reverse(all(answer));",
			"    return answer;",
			"}"
		],
		"description": "bin"
	},
	"bintodec": {
		"prefix": "bintodec",
		"body": [
			"lld bintodec(lld n)",
			"{",
			"    lld num = n;",
			"    lld dec_value = 0;",
			"    lld base = 1;",
			"",
			"    lld temp = num;",
			"    while (temp)",
			"    {",
			"        lld last_digit = temp % 10;",
			"        temp = temp / 10;",
			"",
			"        dec_value += last_digit * base;",
			"",
			"        base = base * 2;",
			"    }",
			"",
			"    return dec_value;",
			"}"
		],
		"description": "bintodec"
	},
	"dectobin": {
		"prefix": "dectobin",
		"body": [
			"string dectobin(lld n)",
			"{",
			"    string s = bitset<64>(n).to_string();",
			"    const auto loc1 = s.find('1');",
			"",
			"    if (loc1 != string::npos)",
			"        return s.substr(loc1);",
			"",
			"    return \"0\";",
			"}"
		],
		"description": "dectobin"
	},
	"binary32bit": {
		"prefix": "binary32bit",
		"body": [
			"string binary32bit(lld n)",
			"{",
			"    string s = bitset<32>(n).to_string();",
			"    return s;",
			"}"
		],
		"description": "binary32bit"
	},
	"binary64bit": {
		"prefix": "binary64bit",
		"body": [
			"string binary64bit(lld n)",
			"{",
			"    string s = bitset<64>(n).to_string();",
			"    return s;",
			"}"
		],
		"description": "binary64bit"
	},
	"kth_no_not_divisible_by_n": {
		"prefix": "kth_no_not_divisible_by_n",
		"body": [
			"lld kth_no_not_divisible_by_n(lld n, lld k)",
			"{",
			"    return k + (k - 1) / (n - 1);",
			"}"
		],
		"description": "kth_no_not_divisible_by_n"
	},
	"reduce value": {
		"prefix": "reduce value",
		"body": [
			"void reduce(map<lld, lld> &m, lld value)",
			"{",
			"    if (m[value] <= 1)",
			"    {",
			"        m.erase(value);",
			"    }",
			"    else",
			"    {",
			"        m[value]--;",
			"    }",
			"}"
		],
		"description": "reduce value"
	},
	"printfunctions": {
		"prefix": "print",
		"body": [
			"void print(lld arr[], lld size)",
			"{",
			"    for (lld i = 0; i < size; i++)",
			"    {",
			"        ps(arr[i]);",
			"    }",
			"    p(\"\");",
			"}",
			"",
			"void print(vl &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cout << v[i] << \" \";",
			"    }",
			"    cout << endl;",
			"}",
			"void print(vector<vl> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        for (lld j = 0; j < v[i].size(); j++)",
			"        {",
			"            ps(v[i][j]);",
			"        }",
			"        p(\"\");",
			"    }",
			"}",
			"void print(vector<string> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cout << v[i] << \" \";",
			"    }",
			"    cout << endl;",
			"}",
			"void print(vector<pll> &v)",
			"{",
			"    for (lld i = 0; i < v.size(); i++)",
			"    {",
			"        cout << v[i].first << \" \" << v[i].second << \" \";",
			"    }",
			"    cout << endl;",
			"}",
			"void prints(vl &v)",
			"{",
			"",
			"    for (lld i = 1; i != v.size(); i++)",
			"    {",
			"        ps(v[i]);",
			"    }",
			"}",
			"void print(set<pll> &seta)",
			"{",
			"",
			"    for (auto i : seta)",
			"    {",
			"        ps2(i.first, i.second);",
			"    }",
			"    p(\"\");",
			"}",
			"void print(map<lld, lld> &mapa)",
			"{",
			"    for (auto i : mapa)",
			"    {",
			"        ps4(\"{\", i.first, i.second, \"}\");",
			"    }",
			"    p(\"\");",
			"}",
			"void print(multimap<lld, lld> &multi)",
			"{",
			"    for (auto i : multi)",
			"    {",
			"        ps4('{', i.first, i.second, '}');",
			"    }",
			"    p(\"\");",
			"}",
			"void print(map<lld, lld, greater<lld>> &mapa)",
			"{",
			"",
			"    for (auto i : mapa)",
			"    {",
			"        ps4(\"{\", i.first, i.second, \"}\");",
			"    }",
			"    p(\"\");",
			"}",
			"void print(set<lld> &seta)",
			"{",
			"    for (auto i : seta)",
			"    {",
			"        ps(i);",
			"    }",
			"    p(\"\");",
			"}",
			"void print(map<pll, pll> &mapa)",
			"{",
			"    for (auto i = mapa.begin(); i != mapa.end(); i++)",
			"    {",
			"        ps4(i->first.first, i->first.second, i->second.first, i->second.second);",
			"    }",
			"}",
			"void print(map<pll, lld> &mapa)",
			"{",
			"",
			"    for (auto i = mapa.begin(); i != mapa.end(); i++)",
			"    {",
			"        ps5(\"{\", i->first.first, i->first.second, i->second, \"}\");",
			"    }",
			"    p(\"\");",
			"}",
			"void print(pll &tuple)",
			"{",
			"",
			"    p2(tuple.first, tuple.second);",
			"}",
			"void print(set<lld, greater<lld>> &s)",
			"{",
			"    for (auto i : s)",
			"    {",
			"        p(i);",
			"    }",
			"}",
			"void print(unordered_set<lld> &seta)",
			"{",
			"    for (auto i : seta)",
			"    {",
			"        ps(i);",
			"    }",
			"    p(\"\");",
			"}",
			"void print(map<lld, set<lld, greater<lld>>, greater<lld>> &m)",
			"{",
			"    for (auto i : m)",
			"    {",
			"        for (auto j : i.second)",
			"        {",
			"            ps(j);",
			"        }",
			"    }",
			"    p(\"\");",
			"}",
			"void print(multiset<lld> &s)",
			"{",
			"    for (auto j : s)",
			"    {",
			"        ps(j);",
			"    }",
			"    p(\"\");",
			"}",
			"void print(map<lld, set<lld>> &m)",
			"{",
			"    for (auto i : m)",
			"    {",
			"        ps2(i.first, \" => \");",
			"        for (auto j : i.second)",
			"        {",
			"            ps(j);",
			"        }",
			"        p(\"\");",
			"    }",
			"}",
			"void print(unordered_map<lld, lld> &um)",
			"{",
			"    for (auto i : um)",
			"    {",
			"        p4(\"{\", i.first, \"->\", i.second);",
			"    }",
			"    p(\"\");",
			"}"
		],
		"description": "printfunctions"
	},
	"z_function": {
		"prefix": "z_function",
		"body": [
			"vector<int> z_function(string s)",
			"{",
			"    int n = (int)s.length();",
			"    vector<int> z(n);",
			"    for (int i = 1, l = 0, r = 0; i < n; ++i)",
			"    {",
			"        if (i <= r)",
			"            z[i] = min(r - i + 1, z[i - l]);",
			"        while (i + z[i] < n && s[z[i]] == s[i + z[i]])",
			"            ++z[i];",
			"        if (i + z[i] - 1 > r)",
			"            l = i, r = i + z[i] - 1;",
			"    }",
			"    return z;",
			"}"
		],
		"description": "z_function"
	},
	"subset_sum": {
		"prefix": "subset_sum",
		"body": [
			"lld subset_sum(vector<int> &v)",
			"{",
			"    const int large = 1e6 + 1;",
			"    bitset<large> b;",
			"    b[0] = 1;",
			"    for (auto i : v)",
			"    {",
			"        b |= (b << i);",
			"    }",
			"    int counter = b.count();",
			"    return counter;",
			"}"
		],
		"description": "subset_sum"
	},
	"reverse iterator": {
		"prefix": "reverse iterator",
		"body": [
			"template <typename T>",
			"struct reversion_wrapper { T& iterable; };",
			"",
			"template <typename T>",
			"auto begin (reversion_wrapper<T> w) { return std::rbegin(w.iterable); }",
			"",
			"template <typename T>",
			"auto end (reversion_wrapper<T> w) { return std::rend(w.iterable); }",
			"",
			"template <typename T>",
			"reversion_wrapper<T> reverse (T&& iterable) { return { iterable }; }"
		],
		"description": "reverse iterator"
	}
}
